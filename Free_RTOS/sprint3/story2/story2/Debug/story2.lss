
story2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001364  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  00001364  000013f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000674  0080007c  0080007c  00001414  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001414  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001444  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003d8  00000000  00000000  00001480  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000044ff  00000000  00000000  00001858  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000152e  00000000  00000000  00005d57  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003217  00000000  00000000  00007285  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009f4  00000000  00000000  0000a49c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000b158  00000000  00000000  0000ae90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000032fe  00000000  00000000  00015fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000368  00000000  00000000  000192e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00002773  00000000  00000000  0001964e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
       2:	00 00       	nop
       4:	44 c0       	rjmp	.+136    	; 0x8e <__bad_interrupt>
       6:	00 00       	nop
       8:	42 c0       	rjmp	.+132    	; 0x8e <__bad_interrupt>
       a:	00 00       	nop
       c:	40 c0       	rjmp	.+128    	; 0x8e <__bad_interrupt>
       e:	00 00       	nop
      10:	3e c0       	rjmp	.+124    	; 0x8e <__bad_interrupt>
      12:	00 00       	nop
      14:	3c c0       	rjmp	.+120    	; 0x8e <__bad_interrupt>
      16:	00 00       	nop
      18:	3a c0       	rjmp	.+116    	; 0x8e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c5 c2       	rjmp	.+1418   	; 0x5a8 <__vector_7>
      1e:	00 00       	nop
      20:	36 c0       	rjmp	.+108    	; 0x8e <__bad_interrupt>
      22:	00 00       	nop
      24:	34 c0       	rjmp	.+104    	; 0x8e <__bad_interrupt>
      26:	00 00       	nop
      28:	32 c0       	rjmp	.+100    	; 0x8e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	30 c0       	rjmp	.+96     	; 0x8e <__bad_interrupt>
      2e:	00 00       	nop
      30:	2e c0       	rjmp	.+92     	; 0x8e <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 6e 09 	jmp	0x12dc	; 0x12dc <__vector_13>
      38:	2a c0       	rjmp	.+84     	; 0x8e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	0c 94 62 09 	jmp	0x12c4	; 0x12c4 <__vector_15>
      40:	26 c0       	rjmp	.+76     	; 0x8e <__bad_interrupt>
      42:	00 00       	nop
      44:	24 c0       	rjmp	.+72     	; 0x8e <__bad_interrupt>
      46:	00 00       	nop
      48:	22 c0       	rjmp	.+68     	; 0x8e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	20 c0       	rjmp	.+64     	; 0x8e <__bad_interrupt>
      4e:	00 00       	nop
      50:	1e c0       	rjmp	.+60     	; 0x8e <__bad_interrupt>
	...

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e6       	ldi	r30, 0x64	; 100
      68:	f3 e1       	ldi	r31, 0x13	; 19
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 3f       	cpi	r26, 0xF0	; 240
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 57 08 	call	0x10ae	; 0x10ae <main>
      8a:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <_exit>

0000008e <__bad_interrupt>:
      8e:	b8 cf       	rjmp	.-144    	; 0x0 <__vectors>

00000090 <UserStoryOneInit>:
* Return value: None
* Description: this function is responsible for the initialization of all modules
* used in this file
************************************************************************************/
void UserStoryOneInit(void)
{
      90:	cf 93       	push	r28
      92:	df 93       	push	r29
      94:	cd b7       	in	r28, 0x3d	; 61
      96:	de b7       	in	r29, 0x3e	; 62
      98:	60 97       	sbiw	r28, 0x10	; 16
      9a:	0f b6       	in	r0, 0x3f	; 63
      9c:	f8 94       	cli
      9e:	de bf       	out	0x3e, r29	; 62
      a0:	0f be       	out	0x3f, r0	; 63
      a2:	cd bf       	out	0x3d, r28	; 61
	TaskHandle_t xHandle = NULL;
	 /* initialize the sytem*/
	Led_Init(LED_0); 
      a4:	80 e0       	ldi	r24, 0x00	; 0
      a6:	25 d7       	rcall	.+3658   	; 0xef2 <Led_Init>
	pushButtonInit(BTN_1);
      a8:	81 e0       	ldi	r24, 0x01	; 1
	LCD_init();
      aa:	8d d7       	rcall	.+3866   	; 0xfc6 <pushButtonInit>
      ac:	ab d6       	rcall	.+3414   	; 0xe04 <LCD_init>
	
	UART_Config_Structure uart_initialization_structure;
	uart_initialization_structure.Char_Size=USART_8_Bit_CHAR;
      ae:	86 e0       	ldi	r24, 0x06	; 6
      b0:	8d 83       	std	Y+5, r24	; 0x05
	uart_initialization_structure.Clk_Polarity_Mode=TX_RISING_RX_FALLING;
      b2:	1c 82       	std	Y+4, r1	; 0x04
	uart_initialization_structure.Speed_Mode=USART_DOUBLE_SPEED;
      b4:	82 e0       	ldi	r24, 0x02	; 2
      b6:	8d 87       	std	Y+13, r24	; 0x0d
	uart_initialization_structure.Parity_Mode=USART_NO_PARITY;
      b8:	1a 82       	std	Y+2, r1	; 0x02
	uart_initialization_structure.Stop_Bit_Mode=USART_1_STOPBIT;
      ba:	1b 82       	std	Y+3, r1	; 0x03
	uart_initialization_structure.Receive_Mode=USART_RECIEVE_ENABLE;
      bc:	80 e1       	ldi	r24, 0x10	; 16
      be:	89 87       	std	Y+9, r24	; 0x09
	uart_initialization_structure.Transmit_Mode=USART_TRANSMIT_ENABLE;
      c0:	88 e0       	ldi	r24, 0x08	; 8
      c2:	8a 87       	std	Y+10, r24	; 0x0a
	uart_initialization_structure.Double_Speed_Baud_Rate=BAUD9600;
      c4:	8f ec       	ldi	r24, 0xCF	; 207
      c6:	90 e0       	ldi	r25, 0x00	; 0
      c8:	98 8b       	std	Y+16, r25	; 0x10
      ca:	8f 87       	std	Y+15, r24	; 0x0f
	uart_initialization_structure.Transmit_Complete_Inter=TX_COMPLETE_INTER_DISABLE;
      cc:	1f 82       	std	Y+7, r1	; 0x07
	uart_initialization_structure.Receive_Complete_Inter=RX_COMPLETE_INTER_ENABLE;
      ce:	80 e8       	ldi	r24, 0x80	; 128
      d0:	8e 83       	std	Y+6, r24	; 0x06
	UART_init(&uart_initialization_structure);
      d2:	ce 01       	movw	r24, r28
      d4:	01 96       	adiw	r24, 0x01	; 1
	
	
	
		xHandle=xTaskGetCurrentTaskHandle();
      d6:	0e 94 3a 09 	call	0x1274	; 0x1274 <UART_init>
		vTaskSuspend(xHandle);
      da:	28 d6       	rcall	.+3152   	; 0xd2c <xTaskGetCurrentTaskHandle>
      dc:	db d5       	rcall	.+2998   	; 0xc94 <vTaskSuspend>
		  		

}
      de:	60 96       	adiw	r28, 0x10	; 16
      e0:	0f b6       	in	r0, 0x3f	; 63
      e2:	f8 94       	cli
      e4:	de bf       	out	0x3e, r29	; 62
      e6:	0f be       	out	0x3f, r0	; 63
      e8:	cd bf       	out	0x3d, r28	; 61
      ea:	df 91       	pop	r29
      ec:	cf 91       	pop	r28
      ee:	08 95       	ret

000000f0 <UserStoryOne>:
* Parameters (out): None
* Return value: None
* Description: this function toggles LED number zero
************************************************************************************/
void UserStoryOne(void)
{	
      f0:	cf 93       	push	r28
      f2:	df 93       	push	r29
      f4:	1f 92       	push	r1
      f6:	cd b7       	in	r28, 0x3d	; 61
      f8:	de b7       	in	r29, 0x3e	; 62
	uint8_t au8_getbtnstatue=Released;
      fa:	81 e0       	ldi	r24, 0x01	; 1
      fc:	89 83       	std	Y+1, r24	; 0x01
    static uint8_t au8_counter;
	static uint8_t au8_counter2;
	uint8_t flag=0;
      fe:	10 e0       	ldi	r17, 0x00	; 0
	while(TRUE)
	{
		pushButtonGetStatus(BTN_1,&au8_getbtnstatue);
     100:	be 01       	movw	r22, r28
     102:	6f 5f       	subi	r22, 0xFF	; 255
     104:	7f 4f       	sbci	r23, 0xFF	; 255
     106:	81 e0       	ldi	r24, 0x01	; 1
     108:	82 d7       	rcall	.+3844   	; 0x100e <pushButtonGetStatus>
		if(au8_getbtnstatue==Pressed)
     10a:	89 81       	ldd	r24, Y+1	; 0x01
     10c:	81 11       	cpse	r24, r1
     10e:	0d c0       	rjmp	.+26     	; 0x12a <UserStoryOne+0x3a>
		{
			au8_counter++;
     110:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <au8_counter.2119>
     114:	8f 5f       	subi	r24, 0xFF	; 255
     116:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <au8_counter.2119>
			if(au8_counter==2)
     11a:	82 30       	cpi	r24, 0x02	; 2
     11c:	31 f4       	brne	.+12     	; 0x12a <UserStoryOne+0x3a>
			{
				gu8_sendflag=1;
     11e:	81 e0       	ldi	r24, 0x01	; 1
     120:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <gu8_sendflag>
				flag=1;
				au8_counter=0;
     124:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <au8_counter.2119>
     128:	02 c0       	rjmp	.+4      	; 0x12e <UserStoryOne+0x3e>
			    
			}
		}
		if(flag==1)
     12a:	11 30       	cpi	r17, 0x01	; 1
     12c:	91 f4       	brne	.+36     	; 0x152 <UserStoryOne+0x62>
		{
           au8_counter2++;
     12e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <au8_counter2.2120>
     132:	8f 5f       	subi	r24, 0xFF	; 255
     134:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <au8_counter2.2120>
		   Led_On(LED_0);
     138:	80 e0       	ldi	r24, 0x00	; 0
     13a:	0d d7       	rcall	.+3610   	; 0xf56 <Led_On>
		   if(au8_counter2==10)
     13c:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <au8_counter2.2120>
     140:	8a 30       	cpi	r24, 0x0A	; 10
     142:	31 f4       	brne	.+12     	; 0x150 <UserStoryOne+0x60>
		   {
			   au8_counter2=0;
     144:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <au8_counter2.2120>
			   flag=0;
			   Led_Off(LED_0);
     148:	80 e0       	ldi	r24, 0x00	; 0
     14a:	21 d7       	rcall	.+3650   	; 0xf8e <Led_Off>
           au8_counter2++;
		   Led_On(LED_0);
		   if(au8_counter2==10)
		   {
			   au8_counter2=0;
			   flag=0;
     14c:	10 e0       	ldi	r17, 0x00	; 0
     14e:	01 c0       	rjmp	.+2      	; 0x152 <UserStoryOne+0x62>
     150:	11 e0       	ldi	r17, 0x01	; 1
			   Led_Off(LED_0);
		   }

		}
		if(g8_UART_RX_FLAG==FLAG_HIGH)
     152:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <g8_UART_RX_FLAG>
     156:	81 30       	cpi	r24, 0x01	; 1
     158:	19 f4       	brne	.+6      	; 0x160 <UserStoryOne+0x70>
		{
			
			flag=1;
			g8_UART_RX_FLAG=FLAG_LOW;
     15a:	10 92 c9 06 	sts	0x06C9, r1	; 0x8006c9 <g8_UART_RX_FLAG>
		}	 
		
        /* Wait for the next cycle */
        vTaskDelay(40);
     15e:	11 e0       	ldi	r17, 0x01	; 1
     160:	88 e2       	ldi	r24, 0x28	; 40
     162:	90 e0       	ldi	r25, 0x00	; 0
     164:	21 d5       	rcall	.+2626   	; 0xba8 <vTaskDelay>
	}
     166:	cc cf       	rjmp	.-104    	; 0x100 <UserStoryOne+0x10>

00000168 <keypadtask>:
		static uint8_t u8_pass_match_flag=CLEAR;
		static uint8_t u8_counter=CLEAR;
		static uint8_t au8_counter=0;

		/* Initialize the xLastWakeTime variable with the current time */
		UserStoryOne_LastWakeTime = xTaskGetTickCount();
     168:	07 d4       	rcall	.+2062   	; 0x978 <xTaskGetTickCount>
		while(TRUE)
		{
			if(u8_waiting_flag == FLAG_HIGH)
     16a:	80 91 7f 00 	lds	r24, 0x007F	; 0x80007f <u8_waiting_flag.2133>
     16e:	81 30       	cpi	r24, 0x01	; 1
     170:	69 f4       	brne	.+26     	; 0x18c <keypadtask+0x24>
			{
				u8_entry_counter++;
     172:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <u8_entry_counter.2131>
     176:	8f 5f       	subi	r24, 0xFF	; 255
     178:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <u8_entry_counter.2131>
				if(u8_entry_counter==ENTRIES_FOR_2_SEC)
     17c:	84 31       	cpi	r24, 0x14	; 20
     17e:	21 f5       	brne	.+72     	; 0x1c8 <keypadtask+0x60>
				{
					u8_entry_counter=CLEAR;
     180:	10 92 7e 00 	sts	0x007E, r1	; 0x80007e <u8_entry_counter.2131>
					u8_waiting_flag=FLAG_LOW;
     184:	10 92 7f 00 	sts	0x007F, r1	; 0x80007f <u8_waiting_flag.2133>
					LCD_clearScreen();
     188:	b1 d6       	rcall	.+3426   	; 0xeec <LCD_clearScreen>
				}
			}
			else
			{
				/* get the pressed key */
				au8_Key = KeyPad_getPressedKey();
     18a:	1e c0       	rjmp	.+60     	; 0x1c8 <keypadtask+0x60>
     18c:	d4 d5       	rcall	.+2984   	; 0xd36 <KeyPad_getPressedKey>
     18e:	c8 2f       	mov	r28, r24

				if(au8_Key != NO_KEY_PRESSED)
     190:	83 36       	cpi	r24, 0x63	; 99
     192:	d1 f0       	breq	.+52     	; 0x1c8 <keypadtask+0x60>
				{
					/* Increment the debouncing counter */
					u8_debouncing_counter++;
     194:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <u8_debouncing_counter.2132>
     198:	8f 5f       	subi	r24, 0xFF	; 255
     19a:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <u8_debouncing_counter.2132>

					/* to prevent any key duplication since the human press is around 100ms */
					if(u8_debouncing_counter==ENTRIES_FOR_DEBOUNCE)
     19e:	82 30       	cpi	r24, 0x02	; 2
     1a0:	99 f4       	brne	.+38     	; 0x1c8 <keypadtask+0x60>
					{
						
						/* clear the debouncing counter */
						u8_debouncing_counter=CLEAR;
     1a2:	10 92 7d 00 	sts	0x007D, r1	; 0x80007d <u8_debouncing_counter.2132>
						/* switch on the key value and take the appropriate action */
						au8_temp_key = au8_Key+ASCII_ADDITION;
     1a6:	d0 e3       	ldi	r29, 0x30	; 48
						LCD_displayCharacter(au8_temp_key);
     1a8:	dc 0f       	add	r29, r28
     1aa:	8d 2f       	mov	r24, r29
						/*erase button is pressed */
						if(au8_Key == '#')
     1ac:	42 d6       	rcall	.+3204   	; 0xe32 <LCD_displayCharacter>
     1ae:	c3 32       	cpi	r28, 0x23	; 35
						{
							/* clear the LCD */
							LCD_clearScreen();
     1b0:	09 f4       	brne	.+2      	; 0x1b4 <keypadtask+0x4c>
     1b2:	9c d6       	rcall	.+3384   	; 0xeec <LCD_clearScreen>
						}
						gau8_datatosend[au8_counter]=au8_temp_key;
     1b4:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     1b8:	e8 2f       	mov	r30, r24
     1ba:	f0 e0       	ldi	r31, 0x00	; 0
     1bc:	e4 53       	subi	r30, 0x34	; 52
     1be:	f9 4f       	sbci	r31, 0xF9	; 249
     1c0:	d0 83       	st	Z, r29
						au8_counter++;			
     1c2:	8f 5f       	subi	r24, 0xFF	; 255
     1c4:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__data_end>
					}

				}

			}
				if(gu8_sendflag==1)
     1c8:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <gu8_sendflag>
     1cc:	81 30       	cpi	r24, 0x01	; 1
     1ce:	b1 f4       	brne	.+44     	; 0x1fc <keypadtask+0x94>
				{
					
					for(i=0;i<au8_counter;i++)
     1d0:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     1d4:	88 23       	and	r24, r24
     1d6:	71 f0       	breq	.+28     	; 0x1f4 <keypadtask+0x8c>
     1d8:	10 e0       	ldi	r17, 0x00	; 0
					{
						UART_sendByte(gau8_datatosend[i]);
     1da:	c1 2f       	mov	r28, r17
     1dc:	d0 e0       	ldi	r29, 0x00	; 0
     1de:	c4 53       	subi	r28, 0x34	; 52
     1e0:	d9 4f       	sbci	r29, 0xF9	; 249
     1e2:	88 81       	ld	r24, Y
     1e4:	0e 94 5e 09 	call	0x12bc	; 0x12bc <UART_sendByte>
						gau8_datatosend[i]=0;
     1e8:	18 82       	st	Y, r1

			}
				if(gu8_sendflag==1)
				{
					
					for(i=0;i<au8_counter;i++)
     1ea:	1f 5f       	subi	r17, 0xFF	; 255
     1ec:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
     1f0:	18 17       	cp	r17, r24
     1f2:	98 f3       	brcs	.-26     	; 0x1da <keypadtask+0x72>
					{
						UART_sendByte(gau8_datatosend[i]);
						gau8_datatosend[i]=0;
					}
					au8_counter=0;
     1f4:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__data_end>
					gu8_sendflag=0;
     1f8:	10 92 cb 06 	sts	0x06CB, r1	; 0x8006cb <gu8_sendflag>
					
				}
				
				
			/* Wait for the next cycle */
			vTaskDelay(30);
     1fc:	8e e1       	ldi	r24, 0x1E	; 30
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	d3 d4       	rcall	.+2470   	; 0xba8 <vTaskDelay>
		}
     202:	b3 cf       	rjmp	.-154    	; 0x16a <keypadtask+0x2>

00000204 <softwareDelayus>:
		}		
	}
}


void softwareDelayus(uint32_t u32_delay_in_US){
     204:	ab 01       	movw	r20, r22
     206:	bc 01       	movw	r22, r24
	
	for (uint16_t counter=0;counter<u32_delay_in_US;counter++){
     208:	41 15       	cp	r20, r1
     20a:	51 05       	cpc	r21, r1
     20c:	61 05       	cpc	r22, r1
     20e:	71 05       	cpc	r23, r1
     210:	71 f4       	brne	.+28     	; 0x22e <softwareDelayus+0x2a>
     212:	08 95       	ret
     214:	01 97       	sbiw	r24, 0x01	; 1
		for(uint16_t internalcounter=0;internalcounter<40;internalcounter++){
     216:	f1 f7       	brne	.-4      	; 0x214 <softwareDelayus+0x10>
}


void softwareDelayus(uint32_t u32_delay_in_US){
	
	for (uint16_t counter=0;counter<u32_delay_in_US;counter++){
     218:	2f 5f       	subi	r18, 0xFF	; 255
     21a:	3f 4f       	sbci	r19, 0xFF	; 255
     21c:	c9 01       	movw	r24, r18
     21e:	a0 e0       	ldi	r26, 0x00	; 0
     220:	b0 e0       	ldi	r27, 0x00	; 0
     222:	84 17       	cp	r24, r20
     224:	95 07       	cpc	r25, r21
     226:	a6 07       	cpc	r26, r22
     228:	b7 07       	cpc	r27, r23
     22a:	18 f0       	brcs	.+6      	; 0x232 <softwareDelayus+0x2e>
     22c:	08 95       	ret
     22e:	20 e0       	ldi	r18, 0x00	; 0
     230:	30 e0       	ldi	r19, 0x00	; 0
		}		
	}
}


void softwareDelayus(uint32_t u32_delay_in_US){
     232:	88 e2       	ldi	r24, 0x28	; 40
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	ee cf       	rjmp	.-36     	; 0x214 <softwareDelayus+0x10>

00000238 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     238:	cf 93       	push	r28
     23a:	df 93       	push	r29
     23c:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     23e:	96 d3       	rcall	.+1836   	; 0x96c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     240:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <pucAlignedHeap.2088>
     244:	90 91 83 00 	lds	r25, 0x0083	; 0x800083 <pucAlignedHeap.2088+0x1>
     248:	89 2b       	or	r24, r25
     24a:	31 f4       	brne	.+12     	; 0x258 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     24c:	87 e8       	ldi	r24, 0x87	; 135
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	90 93 83 00 	sts	0x0083, r25	; 0x800083 <pucAlignedHeap.2088+0x1>
     254:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <pucAlignedHeap.2088>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     258:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <xNextFreeByte>
     25c:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <xNextFreeByte+0x1>
     260:	c9 01       	movw	r24, r18
     262:	8c 0f       	add	r24, r28
     264:	9d 1f       	adc	r25, r29
     266:	8b 3d       	cpi	r24, 0xDB	; 219
     268:	45 e0       	ldi	r20, 0x05	; 5
     26a:	94 07       	cpc	r25, r20
     26c:	70 f4       	brcc	.+28     	; 0x28a <pvPortMalloc+0x52>
     26e:	28 17       	cp	r18, r24
     270:	39 07       	cpc	r19, r25
     272:	70 f4       	brcc	.+28     	; 0x290 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     274:	c0 91 82 00 	lds	r28, 0x0082	; 0x800082 <pucAlignedHeap.2088>
     278:	d0 91 83 00 	lds	r29, 0x0083	; 0x800083 <pucAlignedHeap.2088+0x1>
     27c:	c2 0f       	add	r28, r18
     27e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     280:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <xNextFreeByte+0x1>
     284:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <xNextFreeByte>
     288:	05 c0       	rjmp	.+10     	; 0x294 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     28a:	c0 e0       	ldi	r28, 0x00	; 0
     28c:	d0 e0       	ldi	r29, 0x00	; 0
     28e:	02 c0       	rjmp	.+4      	; 0x294 <pvPortMalloc+0x5c>
     290:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     292:	d0 e0       	ldi	r29, 0x00	; 0
     294:	17 d4       	rcall	.+2094   	; 0xac4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     296:	ce 01       	movw	r24, r28
     298:	df 91       	pop	r29
     29a:	cf 91       	pop	r28
     29c:	08 95       	ret

0000029e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     29e:	08 95       	ret

000002a0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2a0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2a2:	03 96       	adiw	r24, 0x03	; 3
     2a4:	92 83       	std	Z+2, r25	; 0x02
     2a6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2a8:	2f ef       	ldi	r18, 0xFF	; 255
     2aa:	3f ef       	ldi	r19, 0xFF	; 255
     2ac:	34 83       	std	Z+4, r19	; 0x04
     2ae:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2b0:	96 83       	std	Z+6, r25	; 0x06
     2b2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2b4:	90 87       	std	Z+8, r25	; 0x08
     2b6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     2b8:	10 82       	st	Z, r1
     2ba:	08 95       	ret

000002bc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     2bc:	fc 01       	movw	r30, r24
     2be:	11 86       	std	Z+9, r1	; 0x09
     2c0:	10 86       	std	Z+8, r1	; 0x08
     2c2:	08 95       	ret

000002c4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	9c 01       	movw	r18, r24
     2ca:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     2cc:	dc 01       	movw	r26, r24
     2ce:	11 96       	adiw	r26, 0x01	; 1
     2d0:	cd 91       	ld	r28, X+
     2d2:	dc 91       	ld	r29, X
     2d4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2d6:	d3 83       	std	Z+3, r29	; 0x03
     2d8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2da:	8c 81       	ldd	r24, Y+4	; 0x04
     2dc:	9d 81       	ldd	r25, Y+5	; 0x05
     2de:	95 83       	std	Z+5, r25	; 0x05
     2e0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2e2:	8c 81       	ldd	r24, Y+4	; 0x04
     2e4:	9d 81       	ldd	r25, Y+5	; 0x05
     2e6:	dc 01       	movw	r26, r24
     2e8:	13 96       	adiw	r26, 0x03	; 3
     2ea:	7c 93       	st	X, r23
     2ec:	6e 93       	st	-X, r22
     2ee:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     2f0:	7d 83       	std	Y+5, r23	; 0x05
     2f2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     2f4:	31 87       	std	Z+9, r19	; 0x09
     2f6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2f8:	f9 01       	movw	r30, r18
     2fa:	80 81       	ld	r24, Z
     2fc:	8f 5f       	subi	r24, 0xFF	; 255
     2fe:	80 83       	st	Z, r24
}
     300:	df 91       	pop	r29
     302:	cf 91       	pop	r28
     304:	08 95       	ret

00000306 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
     30a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     30c:	48 81       	ld	r20, Y
     30e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     310:	4f 3f       	cpi	r20, 0xFF	; 255
     312:	2f ef       	ldi	r18, 0xFF	; 255
     314:	52 07       	cpc	r21, r18
     316:	21 f4       	brne	.+8      	; 0x320 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     318:	fc 01       	movw	r30, r24
     31a:	a7 81       	ldd	r26, Z+7	; 0x07
     31c:	b0 85       	ldd	r27, Z+8	; 0x08
     31e:	0d c0       	rjmp	.+26     	; 0x33a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     320:	dc 01       	movw	r26, r24
     322:	13 96       	adiw	r26, 0x03	; 3
     324:	01 c0       	rjmp	.+2      	; 0x328 <vListInsert+0x22>
     326:	df 01       	movw	r26, r30
     328:	12 96       	adiw	r26, 0x02	; 2
     32a:	ed 91       	ld	r30, X+
     32c:	fc 91       	ld	r31, X
     32e:	13 97       	sbiw	r26, 0x03	; 3
     330:	20 81       	ld	r18, Z
     332:	31 81       	ldd	r19, Z+1	; 0x01
     334:	42 17       	cp	r20, r18
     336:	53 07       	cpc	r21, r19
     338:	b0 f7       	brcc	.-20     	; 0x326 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     33a:	12 96       	adiw	r26, 0x02	; 2
     33c:	ed 91       	ld	r30, X+
     33e:	fc 91       	ld	r31, X
     340:	13 97       	sbiw	r26, 0x03	; 3
     342:	fb 83       	std	Y+3, r31	; 0x03
     344:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     346:	d5 83       	std	Z+5, r29	; 0x05
     348:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     34a:	bd 83       	std	Y+5, r27	; 0x05
     34c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     34e:	13 96       	adiw	r26, 0x03	; 3
     350:	dc 93       	st	X, r29
     352:	ce 93       	st	-X, r28
     354:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     356:	99 87       	std	Y+9, r25	; 0x09
     358:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     35a:	fc 01       	movw	r30, r24
     35c:	20 81       	ld	r18, Z
     35e:	2f 5f       	subi	r18, 0xFF	; 255
     360:	20 83       	st	Z, r18
}
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     36e:	a0 85       	ldd	r26, Z+8	; 0x08
     370:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     372:	c2 81       	ldd	r28, Z+2	; 0x02
     374:	d3 81       	ldd	r29, Z+3	; 0x03
     376:	84 81       	ldd	r24, Z+4	; 0x04
     378:	95 81       	ldd	r25, Z+5	; 0x05
     37a:	9d 83       	std	Y+5, r25	; 0x05
     37c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     37e:	c4 81       	ldd	r28, Z+4	; 0x04
     380:	d5 81       	ldd	r29, Z+5	; 0x05
     382:	82 81       	ldd	r24, Z+2	; 0x02
     384:	93 81       	ldd	r25, Z+3	; 0x03
     386:	9b 83       	std	Y+3, r25	; 0x03
     388:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     38a:	11 96       	adiw	r26, 0x01	; 1
     38c:	8d 91       	ld	r24, X+
     38e:	9c 91       	ld	r25, X
     390:	12 97       	sbiw	r26, 0x02	; 2
     392:	e8 17       	cp	r30, r24
     394:	f9 07       	cpc	r31, r25
     396:	31 f4       	brne	.+12     	; 0x3a4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     398:	84 81       	ldd	r24, Z+4	; 0x04
     39a:	95 81       	ldd	r25, Z+5	; 0x05
     39c:	12 96       	adiw	r26, 0x02	; 2
     39e:	9c 93       	st	X, r25
     3a0:	8e 93       	st	-X, r24
     3a2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     3a4:	11 86       	std	Z+9, r1	; 0x09
     3a6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3a8:	8c 91       	ld	r24, X
     3aa:	81 50       	subi	r24, 0x01	; 1
     3ac:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     3ae:	8c 91       	ld	r24, X
}
     3b0:	df 91       	pop	r29
     3b2:	cf 91       	pop	r28
     3b4:	08 95       	ret

000003b6 <pxPortInitialiseStack>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     3b6:	31 e1       	ldi	r19, 0x11	; 17
     3b8:	fc 01       	movw	r30, r24
     3ba:	30 83       	st	Z, r19
     3bc:	31 97       	sbiw	r30, 0x01	; 1
     3be:	22 e2       	ldi	r18, 0x22	; 34
     3c0:	20 83       	st	Z, r18
     3c2:	31 97       	sbiw	r30, 0x01	; 1
     3c4:	a3 e3       	ldi	r26, 0x33	; 51
     3c6:	a0 83       	st	Z, r26
     3c8:	31 97       	sbiw	r30, 0x01	; 1
     3ca:	60 83       	st	Z, r22
     3cc:	31 97       	sbiw	r30, 0x01	; 1
     3ce:	70 83       	st	Z, r23
     3d0:	31 97       	sbiw	r30, 0x01	; 1
     3d2:	10 82       	st	Z, r1
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	60 e8       	ldi	r22, 0x80	; 128
     3d8:	60 83       	st	Z, r22
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	10 82       	st	Z, r1
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	62 e0       	ldi	r22, 0x02	; 2
     3e2:	60 83       	st	Z, r22
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	63 e0       	ldi	r22, 0x03	; 3
     3e8:	60 83       	st	Z, r22
     3ea:	31 97       	sbiw	r30, 0x01	; 1
     3ec:	64 e0       	ldi	r22, 0x04	; 4
     3ee:	60 83       	st	Z, r22
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	65 e0       	ldi	r22, 0x05	; 5
     3f4:	60 83       	st	Z, r22
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	66 e0       	ldi	r22, 0x06	; 6
     3fa:	60 83       	st	Z, r22
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	67 e0       	ldi	r22, 0x07	; 7
     400:	60 83       	st	Z, r22
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	68 e0       	ldi	r22, 0x08	; 8
     406:	60 83       	st	Z, r22
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	69 e0       	ldi	r22, 0x09	; 9
     40c:	60 83       	st	Z, r22
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	60 e1       	ldi	r22, 0x10	; 16
     412:	60 83       	st	Z, r22
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	30 83       	st	Z, r19
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	32 e1       	ldi	r19, 0x12	; 18
     41c:	30 83       	st	Z, r19
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	33 e1       	ldi	r19, 0x13	; 19
     422:	30 83       	st	Z, r19
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	34 e1       	ldi	r19, 0x14	; 20
     428:	30 83       	st	Z, r19
     42a:	31 97       	sbiw	r30, 0x01	; 1
     42c:	35 e1       	ldi	r19, 0x15	; 21
     42e:	30 83       	st	Z, r19
     430:	31 97       	sbiw	r30, 0x01	; 1
     432:	36 e1       	ldi	r19, 0x16	; 22
     434:	30 83       	st	Z, r19
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	37 e1       	ldi	r19, 0x17	; 23
     43a:	30 83       	st	Z, r19
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	38 e1       	ldi	r19, 0x18	; 24
     440:	30 83       	st	Z, r19
     442:	31 97       	sbiw	r30, 0x01	; 1
     444:	39 e1       	ldi	r19, 0x19	; 25
     446:	30 83       	st	Z, r19
     448:	31 97       	sbiw	r30, 0x01	; 1
     44a:	30 e2       	ldi	r19, 0x20	; 32
     44c:	30 83       	st	Z, r19
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	31 e2       	ldi	r19, 0x21	; 33
     452:	30 83       	st	Z, r19
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	20 83       	st	Z, r18
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	23 e2       	ldi	r18, 0x23	; 35
     45c:	20 83       	st	Z, r18
     45e:	31 97       	sbiw	r30, 0x01	; 1
     460:	40 83       	st	Z, r20
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	50 83       	st	Z, r21
     466:	31 97       	sbiw	r30, 0x01	; 1
     468:	26 e2       	ldi	r18, 0x26	; 38
     46a:	20 83       	st	Z, r18
     46c:	31 97       	sbiw	r30, 0x01	; 1
     46e:	27 e2       	ldi	r18, 0x27	; 39
     470:	20 83       	st	Z, r18
     472:	31 97       	sbiw	r30, 0x01	; 1
     474:	28 e2       	ldi	r18, 0x28	; 40
     476:	20 83       	st	Z, r18
     478:	31 97       	sbiw	r30, 0x01	; 1
     47a:	29 e2       	ldi	r18, 0x29	; 41
     47c:	20 83       	st	Z, r18
     47e:	31 97       	sbiw	r30, 0x01	; 1
     480:	20 e3       	ldi	r18, 0x30	; 48
     482:	20 83       	st	Z, r18
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	21 e3       	ldi	r18, 0x31	; 49
     488:	20 83       	st	Z, r18
     48a:	86 97       	sbiw	r24, 0x26	; 38
     48c:	08 95       	ret

0000048e <xPortStartScheduler>:
     48e:	1b bc       	out	0x2b, r1	; 43
     490:	89 ef       	ldi	r24, 0xF9	; 249
     492:	8a bd       	out	0x2a, r24	; 42
     494:	8b e0       	ldi	r24, 0x0B	; 11
     496:	8e bd       	out	0x2e, r24	; 46
     498:	89 b7       	in	r24, 0x39	; 57
     49a:	80 61       	ori	r24, 0x10	; 16
     49c:	89 bf       	out	0x39, r24	; 57
     49e:	a0 91 c6 06 	lds	r26, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     4a2:	b0 91 c7 06 	lds	r27, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     4a6:	cd 91       	ld	r28, X+
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	dd 91       	ld	r29, X+
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	ff 91       	pop	r31
     4b0:	ef 91       	pop	r30
     4b2:	df 91       	pop	r29
     4b4:	cf 91       	pop	r28
     4b6:	bf 91       	pop	r27
     4b8:	af 91       	pop	r26
     4ba:	9f 91       	pop	r25
     4bc:	8f 91       	pop	r24
     4be:	7f 91       	pop	r23
     4c0:	6f 91       	pop	r22
     4c2:	5f 91       	pop	r21
     4c4:	4f 91       	pop	r20
     4c6:	3f 91       	pop	r19
     4c8:	2f 91       	pop	r18
     4ca:	1f 91       	pop	r17
     4cc:	0f 91       	pop	r16
     4ce:	ff 90       	pop	r15
     4d0:	ef 90       	pop	r14
     4d2:	df 90       	pop	r13
     4d4:	cf 90       	pop	r12
     4d6:	bf 90       	pop	r11
     4d8:	af 90       	pop	r10
     4da:	9f 90       	pop	r9
     4dc:	8f 90       	pop	r8
     4de:	7f 90       	pop	r7
     4e0:	6f 90       	pop	r6
     4e2:	5f 90       	pop	r5
     4e4:	4f 90       	pop	r4
     4e6:	3f 90       	pop	r3
     4e8:	2f 90       	pop	r2
     4ea:	1f 90       	pop	r1
     4ec:	0f 90       	pop	r0
     4ee:	0f be       	out	0x3f, r0	; 63
     4f0:	0f 90       	pop	r0
     4f2:	08 95       	ret
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	08 95       	ret

000004f8 <vPortYield>:
     4f8:	0f 92       	push	r0
     4fa:	0f b6       	in	r0, 0x3f	; 63
     4fc:	f8 94       	cli
     4fe:	0f 92       	push	r0
     500:	1f 92       	push	r1
     502:	11 24       	eor	r1, r1
     504:	2f 92       	push	r2
     506:	3f 92       	push	r3
     508:	4f 92       	push	r4
     50a:	5f 92       	push	r5
     50c:	6f 92       	push	r6
     50e:	7f 92       	push	r7
     510:	8f 92       	push	r8
     512:	9f 92       	push	r9
     514:	af 92       	push	r10
     516:	bf 92       	push	r11
     518:	cf 92       	push	r12
     51a:	df 92       	push	r13
     51c:	ef 92       	push	r14
     51e:	ff 92       	push	r15
     520:	0f 93       	push	r16
     522:	1f 93       	push	r17
     524:	2f 93       	push	r18
     526:	3f 93       	push	r19
     528:	4f 93       	push	r20
     52a:	5f 93       	push	r21
     52c:	6f 93       	push	r22
     52e:	7f 93       	push	r23
     530:	8f 93       	push	r24
     532:	9f 93       	push	r25
     534:	af 93       	push	r26
     536:	bf 93       	push	r27
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	ef 93       	push	r30
     53e:	ff 93       	push	r31
     540:	a0 91 c6 06 	lds	r26, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     544:	b0 91 c7 06 	lds	r27, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     548:	0d b6       	in	r0, 0x3d	; 61
     54a:	0d 92       	st	X+, r0
     54c:	0e b6       	in	r0, 0x3e	; 62
     54e:	0d 92       	st	X+, r0
     550:	3b d3       	rcall	.+1654   	; 0xbc8 <vTaskSwitchContext>
     552:	a0 91 c6 06 	lds	r26, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     556:	b0 91 c7 06 	lds	r27, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     55a:	cd 91       	ld	r28, X+
     55c:	cd bf       	out	0x3d, r28	; 61
     55e:	dd 91       	ld	r29, X+
     560:	de bf       	out	0x3e, r29	; 62
     562:	ff 91       	pop	r31
     564:	ef 91       	pop	r30
     566:	df 91       	pop	r29
     568:	cf 91       	pop	r28
     56a:	bf 91       	pop	r27
     56c:	af 91       	pop	r26
     56e:	9f 91       	pop	r25
     570:	8f 91       	pop	r24
     572:	7f 91       	pop	r23
     574:	6f 91       	pop	r22
     576:	5f 91       	pop	r21
     578:	4f 91       	pop	r20
     57a:	3f 91       	pop	r19
     57c:	2f 91       	pop	r18
     57e:	1f 91       	pop	r17
     580:	0f 91       	pop	r16
     582:	ff 90       	pop	r15
     584:	ef 90       	pop	r14
     586:	df 90       	pop	r13
     588:	cf 90       	pop	r12
     58a:	bf 90       	pop	r11
     58c:	af 90       	pop	r10
     58e:	9f 90       	pop	r9
     590:	8f 90       	pop	r8
     592:	7f 90       	pop	r7
     594:	6f 90       	pop	r6
     596:	5f 90       	pop	r5
     598:	4f 90       	pop	r4
     59a:	3f 90       	pop	r3
     59c:	2f 90       	pop	r2
     59e:	1f 90       	pop	r1
     5a0:	0f 90       	pop	r0
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	0f 90       	pop	r0
     5a6:	08 95       	ret

000005a8 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect()  __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     5a8:	1f 92       	push	r1
     5aa:	0f 92       	push	r0
     5ac:	0f b6       	in	r0, 0x3f	; 63
     5ae:	0f 92       	push	r0
     5b0:	11 24       	eor	r1, r1
     5b2:	2f 93       	push	r18
     5b4:	3f 93       	push	r19
     5b6:	4f 93       	push	r20
     5b8:	5f 93       	push	r21
     5ba:	6f 93       	push	r22
     5bc:	7f 93       	push	r23
     5be:	8f 93       	push	r24
     5c0:	9f 93       	push	r25
     5c2:	af 93       	push	r26
     5c4:	bf 93       	push	r27
     5c6:	ef 93       	push	r30
     5c8:	ff 93       	push	r31
		xTaskIncrementTick();
     5ca:	e0 d1       	rcall	.+960    	; 0x98c <xTaskIncrementTick>
	}
     5cc:	ff 91       	pop	r31
     5ce:	ef 91       	pop	r30
     5d0:	bf 91       	pop	r27
     5d2:	af 91       	pop	r26
     5d4:	9f 91       	pop	r25
     5d6:	8f 91       	pop	r24
     5d8:	7f 91       	pop	r23
     5da:	6f 91       	pop	r22
     5dc:	5f 91       	pop	r21
     5de:	4f 91       	pop	r20
     5e0:	3f 91       	pop	r19
     5e2:	2f 91       	pop	r18
     5e4:	0f 90       	pop	r0
     5e6:	0f be       	out	0x3f, r0	; 63
     5e8:	0f 90       	pop	r0
     5ea:	1f 90       	pop	r1
     5ec:	18 95       	reti

000005ee <prvResetNextTaskUnblockTime>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     5ee:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
     5f2:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     5f6:	80 81       	ld	r24, Z
     5f8:	81 11       	cpse	r24, r1
     5fa:	07 c0       	rjmp	.+14     	; 0x60a <prvResetNextTaskUnblockTime+0x1c>
     5fc:	8f ef       	ldi	r24, 0xFF	; 255
     5fe:	9f ef       	ldi	r25, 0xFF	; 255
     600:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
     604:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
     608:	08 95       	ret
     60a:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
     60e:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     612:	05 80       	ldd	r0, Z+5	; 0x05
     614:	f6 81       	ldd	r31, Z+6	; 0x06
     616:	e0 2d       	mov	r30, r0
     618:	06 80       	ldd	r0, Z+6	; 0x06
     61a:	f7 81       	ldd	r31, Z+7	; 0x07
     61c:	e0 2d       	mov	r30, r0
     61e:	82 81       	ldd	r24, Z+2	; 0x02
     620:	93 81       	ldd	r25, Z+3	; 0x03
     622:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
     626:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
     62a:	08 95       	ret

0000062c <prvIdleTask>:
     62c:	0a e7       	ldi	r16, 0x7A	; 122
     62e:	16 e0       	ldi	r17, 0x06	; 6
     630:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     634:	88 23       	and	r24, r24
     636:	11 f1       	breq	.+68     	; 0x67c <prvIdleTask+0x50>
     638:	0f b6       	in	r0, 0x3f	; 63
     63a:	f8 94       	cli
     63c:	0f 92       	push	r0
     63e:	d8 01       	movw	r26, r16
     640:	15 96       	adiw	r26, 0x05	; 5
     642:	ed 91       	ld	r30, X+
     644:	fc 91       	ld	r31, X
     646:	16 97       	sbiw	r26, 0x06	; 6
     648:	c6 81       	ldd	r28, Z+6	; 0x06
     64a:	d7 81       	ldd	r29, Z+7	; 0x07
     64c:	ce 01       	movw	r24, r28
     64e:	02 96       	adiw	r24, 0x02	; 2
     650:	8b de       	rcall	.-746    	; 0x368 <uxListRemove>
     652:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
     656:	81 50       	subi	r24, 0x01	; 1
     658:	80 93 6f 06 	sts	0x066F, r24	; 0x80066f <uxCurrentNumberOfTasks>
     65c:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     660:	81 50       	subi	r24, 0x01	; 1
     662:	80 93 79 06 	sts	0x0679, r24	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     666:	0f 90       	pop	r0
     668:	0f be       	out	0x3f, r0	; 63
     66a:	8f 89       	ldd	r24, Y+23	; 0x17
     66c:	98 8d       	ldd	r25, Y+24	; 0x18
     66e:	17 de       	rcall	.-978    	; 0x29e <vPortFree>
     670:	ce 01       	movw	r24, r28
     672:	15 de       	rcall	.-982    	; 0x29e <vPortFree>
     674:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     678:	81 11       	cpse	r24, r1
     67a:	de cf       	rjmp	.-68     	; 0x638 <prvIdleTask+0xc>
     67c:	3d df       	rcall	.-390    	; 0x4f8 <vPortYield>
     67e:	d8 cf       	rjmp	.-80     	; 0x630 <prvIdleTask+0x4>

00000680 <prvAddCurrentTaskToDelayedList>:
     680:	ff 92       	push	r15
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	ec 01       	movw	r28, r24
     68c:	f6 2e       	mov	r15, r22
     68e:	00 91 6d 06 	lds	r16, 0x066D	; 0x80066d <xTickCount>
     692:	10 91 6e 06 	lds	r17, 0x066E	; 0x80066e <xTickCount+0x1>
     696:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     69a:	90 91 c7 06 	lds	r25, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     69e:	02 96       	adiw	r24, 0x02	; 2
     6a0:	63 de       	rcall	.-826    	; 0x368 <uxListRemove>
     6a2:	cf 3f       	cpi	r28, 0xFF	; 255
     6a4:	8f ef       	ldi	r24, 0xFF	; 255
     6a6:	d8 07       	cpc	r29, r24
     6a8:	61 f4       	brne	.+24     	; 0x6c2 <prvAddCurrentTaskToDelayedList+0x42>
     6aa:	ff 20       	and	r15, r15
     6ac:	51 f0       	breq	.+20     	; 0x6c2 <prvAddCurrentTaskToDelayedList+0x42>
     6ae:	60 91 c6 06 	lds	r22, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     6b2:	70 91 c7 06 	lds	r23, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     6b6:	6e 5f       	subi	r22, 0xFE	; 254
     6b8:	7f 4f       	sbci	r23, 0xFF	; 255
     6ba:	80 e7       	ldi	r24, 0x70	; 112
     6bc:	96 e0       	ldi	r25, 0x06	; 6
     6be:	02 de       	rcall	.-1020   	; 0x2c4 <vListInsertEnd>
     6c0:	2d c0       	rjmp	.+90     	; 0x71c <prvAddCurrentTaskToDelayedList+0x9c>
     6c2:	c0 0f       	add	r28, r16
     6c4:	d1 1f       	adc	r29, r17
     6c6:	e0 91 c6 06 	lds	r30, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     6ca:	f0 91 c7 06 	lds	r31, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     6ce:	d3 83       	std	Z+3, r29	; 0x03
     6d0:	c2 83       	std	Z+2, r28	; 0x02
     6d2:	c0 17       	cp	r28, r16
     6d4:	d1 07       	cpc	r29, r17
     6d6:	60 f4       	brcc	.+24     	; 0x6f0 <prvAddCurrentTaskToDelayedList+0x70>
     6d8:	60 91 c6 06 	lds	r22, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     6dc:	70 91 c7 06 	lds	r23, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     6e0:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <pxOverflowDelayedTaskList>
     6e4:	90 91 8d 06 	lds	r25, 0x068D	; 0x80068d <pxOverflowDelayedTaskList+0x1>
     6e8:	6e 5f       	subi	r22, 0xFE	; 254
     6ea:	7f 4f       	sbci	r23, 0xFF	; 255
     6ec:	0c de       	rcall	.-1000   	; 0x306 <vListInsert>
     6ee:	16 c0       	rjmp	.+44     	; 0x71c <prvAddCurrentTaskToDelayedList+0x9c>
     6f0:	60 91 c6 06 	lds	r22, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     6f4:	70 91 c7 06 	lds	r23, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     6f8:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <pxDelayedTaskList>
     6fc:	90 91 8f 06 	lds	r25, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     700:	6e 5f       	subi	r22, 0xFE	; 254
     702:	7f 4f       	sbci	r23, 0xFF	; 255
     704:	00 de       	rcall	.-1024   	; 0x306 <vListInsert>
     706:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xNextTaskUnblockTime>
     70a:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <xNextTaskUnblockTime+0x1>
     70e:	c8 17       	cp	r28, r24
     710:	d9 07       	cpc	r29, r25
     712:	20 f4       	brcc	.+8      	; 0x71c <prvAddCurrentTaskToDelayedList+0x9c>
     714:	d0 93 66 06 	sts	0x0666, r29	; 0x800666 <xNextTaskUnblockTime+0x1>
     718:	c0 93 65 06 	sts	0x0665, r28	; 0x800665 <xNextTaskUnblockTime>
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	1f 91       	pop	r17
     722:	0f 91       	pop	r16
     724:	ff 90       	pop	r15
     726:	08 95       	ret

00000728 <xTaskCreate>:
     728:	4f 92       	push	r4
     72a:	5f 92       	push	r5
     72c:	6f 92       	push	r6
     72e:	7f 92       	push	r7
     730:	8f 92       	push	r8
     732:	9f 92       	push	r9
     734:	af 92       	push	r10
     736:	bf 92       	push	r11
     738:	cf 92       	push	r12
     73a:	df 92       	push	r13
     73c:	ef 92       	push	r14
     73e:	ff 92       	push	r15
     740:	0f 93       	push	r16
     742:	cf 93       	push	r28
     744:	df 93       	push	r29
     746:	4c 01       	movw	r8, r24
     748:	6b 01       	movw	r12, r22
     74a:	5a 01       	movw	r10, r20
     74c:	29 01       	movw	r4, r18
     74e:	ca 01       	movw	r24, r20
     750:	73 dd       	rcall	.-1306   	; 0x238 <pvPortMalloc>
     752:	3c 01       	movw	r6, r24
     754:	89 2b       	or	r24, r25
     756:	09 f4       	brne	.+2      	; 0x75a <xTaskCreate+0x32>
     758:	d0 c0       	rjmp	.+416    	; 0x8fa <__stack+0x9b>
     75a:	86 e2       	ldi	r24, 0x26	; 38
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	6c dd       	rcall	.-1320   	; 0x238 <pvPortMalloc>
     760:	ec 01       	movw	r28, r24
     762:	89 2b       	or	r24, r25
     764:	59 f0       	breq	.+22     	; 0x77c <xTaskCreate+0x54>
     766:	78 8e       	std	Y+24, r7	; 0x18
     768:	6f 8a       	std	Y+23, r6	; 0x17
     76a:	81 e0       	ldi	r24, 0x01	; 1
     76c:	a8 1a       	sub	r10, r24
     76e:	b1 08       	sbc	r11, r1
     770:	a6 0c       	add	r10, r6
     772:	b7 1c       	adc	r11, r7
     774:	c1 14       	cp	r12, r1
     776:	d1 04       	cpc	r13, r1
     778:	21 f4       	brne	.+8      	; 0x782 <xTaskCreate+0x5a>
     77a:	1f c0       	rjmp	.+62     	; 0x7ba <xTaskCreate+0x92>
     77c:	c3 01       	movw	r24, r6
     77e:	8f dd       	rcall	.-1250   	; 0x29e <vPortFree>
     780:	bc c0       	rjmp	.+376    	; 0x8fa <__stack+0x9b>
     782:	d6 01       	movw	r26, r12
     784:	8c 91       	ld	r24, X
     786:	89 8f       	std	Y+25, r24	; 0x19
     788:	8c 91       	ld	r24, X
     78a:	88 23       	and	r24, r24
     78c:	a1 f0       	breq	.+40     	; 0x7b6 <xTaskCreate+0x8e>
     78e:	ae 01       	movw	r20, r28
     790:	46 5e       	subi	r20, 0xE6	; 230
     792:	5f 4f       	sbci	r21, 0xFF	; 255
     794:	f6 01       	movw	r30, r12
     796:	31 96       	adiw	r30, 0x01	; 1
     798:	b8 e0       	ldi	r27, 0x08	; 8
     79a:	cb 0e       	add	r12, r27
     79c:	d1 1c       	adc	r13, r1
     79e:	cf 01       	movw	r24, r30
     7a0:	21 91       	ld	r18, Z+
     7a2:	da 01       	movw	r26, r20
     7a4:	2d 93       	st	X+, r18
     7a6:	ad 01       	movw	r20, r26
     7a8:	dc 01       	movw	r26, r24
     7aa:	8c 91       	ld	r24, X
     7ac:	88 23       	and	r24, r24
     7ae:	19 f0       	breq	.+6      	; 0x7b6 <xTaskCreate+0x8e>
     7b0:	ec 15       	cp	r30, r12
     7b2:	fd 05       	cpc	r31, r13
     7b4:	a1 f7       	brne	.-24     	; 0x79e <xTaskCreate+0x76>
     7b6:	18 a2       	std	Y+32, r1	; 0x20
     7b8:	01 c0       	rjmp	.+2      	; 0x7bc <xTaskCreate+0x94>
     7ba:	19 8e       	std	Y+25, r1	; 0x19
     7bc:	04 30       	cpi	r16, 0x04	; 4
     7be:	08 f0       	brcs	.+2      	; 0x7c2 <xTaskCreate+0x9a>
     7c0:	03 e0       	ldi	r16, 0x03	; 3
     7c2:	0e 8b       	std	Y+22, r16	; 0x16
     7c4:	6e 01       	movw	r12, r28
     7c6:	b2 e0       	ldi	r27, 0x02	; 2
     7c8:	cb 0e       	add	r12, r27
     7ca:	d1 1c       	adc	r13, r1
     7cc:	c6 01       	movw	r24, r12
     7ce:	76 dd       	rcall	.-1300   	; 0x2bc <vListInitialiseItem>
     7d0:	ce 01       	movw	r24, r28
     7d2:	0c 96       	adiw	r24, 0x0c	; 12
     7d4:	73 dd       	rcall	.-1306   	; 0x2bc <vListInitialiseItem>
     7d6:	d9 87       	std	Y+9, r29	; 0x09
     7d8:	c8 87       	std	Y+8, r28	; 0x08
     7da:	84 e0       	ldi	r24, 0x04	; 4
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	80 1b       	sub	r24, r16
     7e0:	91 09       	sbc	r25, r1
     7e2:	9d 87       	std	Y+13, r25	; 0x0d
     7e4:	8c 87       	std	Y+12, r24	; 0x0c
     7e6:	db 8b       	std	Y+19, r29	; 0x13
     7e8:	ca 8b       	std	Y+18, r28	; 0x12
     7ea:	19 a2       	std	Y+33, r1	; 0x21
     7ec:	1a a2       	std	Y+34, r1	; 0x22
     7ee:	1b a2       	std	Y+35, r1	; 0x23
     7f0:	1c a2       	std	Y+36, r1	; 0x24
     7f2:	1d a2       	std	Y+37, r1	; 0x25
     7f4:	a2 01       	movw	r20, r4
     7f6:	b4 01       	movw	r22, r8
     7f8:	c5 01       	movw	r24, r10
     7fa:	dd dd       	rcall	.-1094   	; 0x3b6 <pxPortInitialiseStack>
     7fc:	99 83       	std	Y+1, r25	; 0x01
     7fe:	88 83       	st	Y, r24
     800:	e1 14       	cp	r14, r1
     802:	f1 04       	cpc	r15, r1
     804:	19 f0       	breq	.+6      	; 0x80c <xTaskCreate+0xe4>
     806:	f7 01       	movw	r30, r14
     808:	d1 83       	std	Z+1, r29	; 0x01
     80a:	c0 83       	st	Z, r28
     80c:	0f b6       	in	r0, 0x3f	; 63
     80e:	f8 94       	cli
     810:	0f 92       	push	r0
     812:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
     816:	8f 5f       	subi	r24, 0xFF	; 255
     818:	80 93 6f 06 	sts	0x066F, r24	; 0x80066f <uxCurrentNumberOfTasks>
     81c:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     820:	90 91 c7 06 	lds	r25, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     824:	89 2b       	or	r24, r25
     826:	89 f5       	brne	.+98     	; 0x88a <__stack+0x2b>
     828:	d0 93 c7 06 	sts	0x06C7, r29	; 0x8006c7 <pxCurrentTCB+0x1>
     82c:	c0 93 c6 06 	sts	0x06C6, r28	; 0x8006c6 <pxCurrentTCB>
     830:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	09 f0       	breq	.+2      	; 0x83a <xTaskCreate+0x112>
     838:	38 c0       	rjmp	.+112    	; 0x8aa <__stack+0x4b>
     83a:	82 ea       	ldi	r24, 0xA2	; 162
     83c:	96 e0       	ldi	r25, 0x06	; 6
     83e:	30 dd       	rcall	.-1440   	; 0x2a0 <vListInitialise>
     840:	8b ea       	ldi	r24, 0xAB	; 171
     842:	96 e0       	ldi	r25, 0x06	; 6
     844:	2d dd       	rcall	.-1446   	; 0x2a0 <vListInitialise>
     846:	84 eb       	ldi	r24, 0xB4	; 180
     848:	96 e0       	ldi	r25, 0x06	; 6
     84a:	2a dd       	rcall	.-1452   	; 0x2a0 <vListInitialise>
     84c:	8d eb       	ldi	r24, 0xBD	; 189
     84e:	96 e0       	ldi	r25, 0x06	; 6
     850:	27 dd       	rcall	.-1458   	; 0x2a0 <vListInitialise>
     852:	89 e9       	ldi	r24, 0x99	; 153
     854:	96 e0       	ldi	r25, 0x06	; 6
     856:	24 dd       	rcall	.-1464   	; 0x2a0 <vListInitialise>
     858:	80 e9       	ldi	r24, 0x90	; 144
     85a:	96 e0       	ldi	r25, 0x06	; 6
     85c:	21 dd       	rcall	.-1470   	; 0x2a0 <vListInitialise>
     85e:	83 e8       	ldi	r24, 0x83	; 131
     860:	96 e0       	ldi	r25, 0x06	; 6
     862:	1e dd       	rcall	.-1476   	; 0x2a0 <vListInitialise>
     864:	8a e7       	ldi	r24, 0x7A	; 122
     866:	96 e0       	ldi	r25, 0x06	; 6
     868:	1b dd       	rcall	.-1482   	; 0x2a0 <vListInitialise>
     86a:	80 e7       	ldi	r24, 0x70	; 112
     86c:	96 e0       	ldi	r25, 0x06	; 6
     86e:	18 dd       	rcall	.-1488   	; 0x2a0 <vListInitialise>
     870:	89 e9       	ldi	r24, 0x99	; 153
     872:	96 e0       	ldi	r25, 0x06	; 6
     874:	90 93 8f 06 	sts	0x068F, r25	; 0x80068f <pxDelayedTaskList+0x1>
     878:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <pxDelayedTaskList>
     87c:	80 e9       	ldi	r24, 0x90	; 144
     87e:	96 e0       	ldi	r25, 0x06	; 6
     880:	90 93 8d 06 	sts	0x068D, r25	; 0x80068d <pxOverflowDelayedTaskList+0x1>
     884:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <pxOverflowDelayedTaskList>
     888:	10 c0       	rjmp	.+32     	; 0x8aa <__stack+0x4b>
     88a:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
     88e:	81 11       	cpse	r24, r1
     890:	0c c0       	rjmp	.+24     	; 0x8aa <__stack+0x4b>
     892:	e0 91 c6 06 	lds	r30, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     896:	f0 91 c7 06 	lds	r31, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     89a:	96 89       	ldd	r25, Z+22	; 0x16
     89c:	8e 89       	ldd	r24, Y+22	; 0x16
     89e:	89 17       	cp	r24, r25
     8a0:	20 f0       	brcs	.+8      	; 0x8aa <__stack+0x4b>
     8a2:	d0 93 c7 06 	sts	0x06C7, r29	; 0x8006c7 <pxCurrentTCB+0x1>
     8a6:	c0 93 c6 06 	sts	0x06C6, r28	; 0x8006c6 <pxCurrentTCB>
     8aa:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <uxTaskNumber>
     8ae:	8f 5f       	subi	r24, 0xFF	; 255
     8b0:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <uxTaskNumber>
     8b4:	8e 89       	ldd	r24, Y+22	; 0x16
     8b6:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
     8ba:	98 17       	cp	r25, r24
     8bc:	10 f4       	brcc	.+4      	; 0x8c2 <__stack+0x63>
     8be:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	9c 01       	movw	r18, r24
     8c6:	22 0f       	add	r18, r18
     8c8:	33 1f       	adc	r19, r19
     8ca:	22 0f       	add	r18, r18
     8cc:	33 1f       	adc	r19, r19
     8ce:	22 0f       	add	r18, r18
     8d0:	33 1f       	adc	r19, r19
     8d2:	82 0f       	add	r24, r18
     8d4:	93 1f       	adc	r25, r19
     8d6:	b6 01       	movw	r22, r12
     8d8:	8e 55       	subi	r24, 0x5E	; 94
     8da:	99 4f       	sbci	r25, 0xF9	; 249
     8dc:	f3 dc       	rcall	.-1562   	; 0x2c4 <vListInsertEnd>
     8de:	0f 90       	pop	r0
     8e0:	0f be       	out	0x3f, r0	; 63
     8e2:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
     8e6:	88 23       	and	r24, r24
     8e8:	31 f0       	breq	.+12     	; 0x8f6 <__stack+0x97>
     8ea:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     8ee:	90 91 c7 06 	lds	r25, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	03 c0       	rjmp	.+6      	; 0x8fc <__stack+0x9d>
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	01 c0       	rjmp	.+2      	; 0x8fc <__stack+0x9d>
     8fa:	8f ef       	ldi	r24, 0xFF	; 255
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28
     900:	0f 91       	pop	r16
     902:	ff 90       	pop	r15
     904:	ef 90       	pop	r14
     906:	df 90       	pop	r13
     908:	cf 90       	pop	r12
     90a:	bf 90       	pop	r11
     90c:	af 90       	pop	r10
     90e:	9f 90       	pop	r9
     910:	8f 90       	pop	r8
     912:	7f 90       	pop	r7
     914:	6f 90       	pop	r6
     916:	5f 90       	pop	r5
     918:	4f 90       	pop	r4
     91a:	08 95       	ret

0000091c <vTaskStartScheduler>:
     91c:	ef 92       	push	r14
     91e:	ff 92       	push	r15
     920:	0f 93       	push	r16
     922:	0f 2e       	mov	r0, r31
     924:	f3 e6       	ldi	r31, 0x63	; 99
     926:	ef 2e       	mov	r14, r31
     928:	f6 e0       	ldi	r31, 0x06	; 6
     92a:	ff 2e       	mov	r15, r31
     92c:	f0 2d       	mov	r31, r0
     92e:	00 e0       	ldi	r16, 0x00	; 0
     930:	20 e0       	ldi	r18, 0x00	; 0
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	45 e5       	ldi	r20, 0x55	; 85
     936:	50 e0       	ldi	r21, 0x00	; 0
     938:	60 e6       	ldi	r22, 0x60	; 96
     93a:	70 e0       	ldi	r23, 0x00	; 0
     93c:	86 e1       	ldi	r24, 0x16	; 22
     93e:	93 e0       	ldi	r25, 0x03	; 3
     940:	f3 de       	rcall	.-538    	; 0x728 <xTaskCreate>
     942:	81 30       	cpi	r24, 0x01	; 1
     944:	79 f4       	brne	.+30     	; 0x964 <vTaskStartScheduler+0x48>
     946:	f8 94       	cli
     948:	8f ef       	ldi	r24, 0xFF	; 255
     94a:	9f ef       	ldi	r25, 0xFF	; 255
     94c:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
     950:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	80 93 6b 06 	sts	0x066B, r24	; 0x80066b <xSchedulerRunning>
     95a:	10 92 6e 06 	sts	0x066E, r1	; 0x80066e <xTickCount+0x1>
     95e:	10 92 6d 06 	sts	0x066D, r1	; 0x80066d <xTickCount>
     962:	95 dd       	rcall	.-1238   	; 0x48e <xPortStartScheduler>
     964:	0f 91       	pop	r16
     966:	ff 90       	pop	r15
     968:	ef 90       	pop	r14
     96a:	08 95       	ret

0000096c <vTaskSuspendAll>:
     96c:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     970:	8f 5f       	subi	r24, 0xFF	; 255
     972:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxSchedulerSuspended>
     976:	08 95       	ret

00000978 <xTaskGetTickCount>:
     978:	0f b6       	in	r0, 0x3f	; 63
     97a:	f8 94       	cli
     97c:	0f 92       	push	r0
     97e:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <xTickCount>
     982:	90 91 6e 06 	lds	r25, 0x066E	; 0x80066e <xTickCount+0x1>
     986:	0f 90       	pop	r0
     988:	0f be       	out	0x3f, r0	; 63
     98a:	08 95       	ret

0000098c <xTaskIncrementTick>:
     98c:	ef 92       	push	r14
     98e:	ff 92       	push	r15
     990:	0f 93       	push	r16
     992:	1f 93       	push	r17
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     99c:	81 11       	cpse	r24, r1
     99e:	85 c0       	rjmp	.+266    	; 0xaaa <xTaskIncrementTick+0x11e>
     9a0:	e0 90 6d 06 	lds	r14, 0x066D	; 0x80066d <xTickCount>
     9a4:	f0 90 6e 06 	lds	r15, 0x066E	; 0x80066e <xTickCount+0x1>
     9a8:	8f ef       	ldi	r24, 0xFF	; 255
     9aa:	e8 1a       	sub	r14, r24
     9ac:	f8 0a       	sbc	r15, r24
     9ae:	f0 92 6e 06 	sts	0x066E, r15	; 0x80066e <xTickCount+0x1>
     9b2:	e0 92 6d 06 	sts	0x066D, r14	; 0x80066d <xTickCount>
     9b6:	e1 14       	cp	r14, r1
     9b8:	f1 04       	cpc	r15, r1
     9ba:	b1 f4       	brne	.+44     	; 0x9e8 <xTaskIncrementTick+0x5c>
     9bc:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <pxDelayedTaskList>
     9c0:	90 91 8f 06 	lds	r25, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     9c4:	20 91 8c 06 	lds	r18, 0x068C	; 0x80068c <pxOverflowDelayedTaskList>
     9c8:	30 91 8d 06 	lds	r19, 0x068D	; 0x80068d <pxOverflowDelayedTaskList+0x1>
     9cc:	30 93 8f 06 	sts	0x068F, r19	; 0x80068f <pxDelayedTaskList+0x1>
     9d0:	20 93 8e 06 	sts	0x068E, r18	; 0x80068e <pxDelayedTaskList>
     9d4:	90 93 8d 06 	sts	0x068D, r25	; 0x80068d <pxOverflowDelayedTaskList+0x1>
     9d8:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <pxOverflowDelayedTaskList>
     9dc:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <xNumOfOverflows>
     9e0:	8f 5f       	subi	r24, 0xFF	; 255
     9e2:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <xNumOfOverflows>
     9e6:	03 de       	rcall	.-1018   	; 0x5ee <prvResetNextTaskUnblockTime>
     9e8:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xNextTaskUnblockTime>
     9ec:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <xNextTaskUnblockTime+0x1>
     9f0:	e8 16       	cp	r14, r24
     9f2:	f9 06       	cpc	r15, r25
     9f4:	08 f4       	brcc	.+2      	; 0x9f8 <xTaskIncrementTick+0x6c>
     9f6:	5e c0       	rjmp	.+188    	; 0xab4 <xTaskIncrementTick+0x128>
     9f8:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
     9fc:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     a00:	80 81       	ld	r24, Z
     a02:	88 23       	and	r24, r24
     a04:	79 f0       	breq	.+30     	; 0xa24 <xTaskIncrementTick+0x98>
     a06:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
     a0a:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     a0e:	05 80       	ldd	r0, Z+5	; 0x05
     a10:	f6 81       	ldd	r31, Z+6	; 0x06
     a12:	e0 2d       	mov	r30, r0
     a14:	c6 81       	ldd	r28, Z+6	; 0x06
     a16:	d7 81       	ldd	r29, Z+7	; 0x07
     a18:	8a 81       	ldd	r24, Y+2	; 0x02
     a1a:	9b 81       	ldd	r25, Y+3	; 0x03
     a1c:	e8 16       	cp	r14, r24
     a1e:	f9 06       	cpc	r15, r25
     a20:	d8 f4       	brcc	.+54     	; 0xa58 <xTaskIncrementTick+0xcc>
     a22:	15 c0       	rjmp	.+42     	; 0xa4e <xTaskIncrementTick+0xc2>
     a24:	8f ef       	ldi	r24, 0xFF	; 255
     a26:	9f ef       	ldi	r25, 0xFF	; 255
     a28:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
     a2c:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
     a30:	41 c0       	rjmp	.+130    	; 0xab4 <xTaskIncrementTick+0x128>
     a32:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
     a36:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     a3a:	05 80       	ldd	r0, Z+5	; 0x05
     a3c:	f6 81       	ldd	r31, Z+6	; 0x06
     a3e:	e0 2d       	mov	r30, r0
     a40:	c6 81       	ldd	r28, Z+6	; 0x06
     a42:	d7 81       	ldd	r29, Z+7	; 0x07
     a44:	8a 81       	ldd	r24, Y+2	; 0x02
     a46:	9b 81       	ldd	r25, Y+3	; 0x03
     a48:	e8 16       	cp	r14, r24
     a4a:	f9 06       	cpc	r15, r25
     a4c:	28 f4       	brcc	.+10     	; 0xa58 <xTaskIncrementTick+0xcc>
     a4e:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
     a52:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
     a56:	2e c0       	rjmp	.+92     	; 0xab4 <xTaskIncrementTick+0x128>
     a58:	8e 01       	movw	r16, r28
     a5a:	0e 5f       	subi	r16, 0xFE	; 254
     a5c:	1f 4f       	sbci	r17, 0xFF	; 255
     a5e:	c8 01       	movw	r24, r16
     a60:	83 dc       	rcall	.-1786   	; 0x368 <uxListRemove>
     a62:	8c 89       	ldd	r24, Y+20	; 0x14
     a64:	9d 89       	ldd	r25, Y+21	; 0x15
     a66:	89 2b       	or	r24, r25
     a68:	19 f0       	breq	.+6      	; 0xa70 <xTaskIncrementTick+0xe4>
     a6a:	ce 01       	movw	r24, r28
     a6c:	0c 96       	adiw	r24, 0x0c	; 12
     a6e:	7c dc       	rcall	.-1800   	; 0x368 <uxListRemove>
     a70:	8e 89       	ldd	r24, Y+22	; 0x16
     a72:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
     a76:	98 17       	cp	r25, r24
     a78:	10 f4       	brcc	.+4      	; 0xa7e <xTaskIncrementTick+0xf2>
     a7a:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	9c 01       	movw	r18, r24
     a82:	22 0f       	add	r18, r18
     a84:	33 1f       	adc	r19, r19
     a86:	22 0f       	add	r18, r18
     a88:	33 1f       	adc	r19, r19
     a8a:	22 0f       	add	r18, r18
     a8c:	33 1f       	adc	r19, r19
     a8e:	82 0f       	add	r24, r18
     a90:	93 1f       	adc	r25, r19
     a92:	b8 01       	movw	r22, r16
     a94:	8e 55       	subi	r24, 0x5E	; 94
     a96:	99 4f       	sbci	r25, 0xF9	; 249
     a98:	15 dc       	rcall	.-2006   	; 0x2c4 <vListInsertEnd>
     a9a:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
     a9e:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
     aa2:	80 81       	ld	r24, Z
     aa4:	81 11       	cpse	r24, r1
     aa6:	c5 cf       	rjmp	.-118    	; 0xa32 <xTaskIncrementTick+0xa6>
     aa8:	bd cf       	rjmp	.-134    	; 0xa24 <xTaskIncrementTick+0x98>
     aaa:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <uxPendedTicks>
     aae:	8f 5f       	subi	r24, 0xFF	; 255
     ab0:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <uxPendedTicks>
     ab4:	80 e0       	ldi	r24, 0x00	; 0
     ab6:	df 91       	pop	r29
     ab8:	cf 91       	pop	r28
     aba:	1f 91       	pop	r17
     abc:	0f 91       	pop	r16
     abe:	ff 90       	pop	r15
     ac0:	ef 90       	pop	r14
     ac2:	08 95       	ret

00000ac4 <xTaskResumeAll>:
     ac4:	df 92       	push	r13
     ac6:	ef 92       	push	r14
     ac8:	ff 92       	push	r15
     aca:	0f 93       	push	r16
     acc:	1f 93       	push	r17
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	0f 92       	push	r0
     ad8:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     adc:	81 50       	subi	r24, 0x01	; 1
     ade:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxSchedulerSuspended>
     ae2:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     ae6:	81 11       	cpse	r24, r1
     ae8:	54 c0       	rjmp	.+168    	; 0xb92 <xTaskResumeAll+0xce>
     aea:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
     aee:	81 11       	cpse	r24, r1
     af0:	30 c0       	rjmp	.+96     	; 0xb52 <xTaskResumeAll+0x8e>
     af2:	4f c0       	rjmp	.+158    	; 0xb92 <xTaskResumeAll+0xce>
     af4:	d7 01       	movw	r26, r14
     af6:	15 96       	adiw	r26, 0x05	; 5
     af8:	ed 91       	ld	r30, X+
     afa:	fc 91       	ld	r31, X
     afc:	16 97       	sbiw	r26, 0x06	; 6
     afe:	c6 81       	ldd	r28, Z+6	; 0x06
     b00:	d7 81       	ldd	r29, Z+7	; 0x07
     b02:	ce 01       	movw	r24, r28
     b04:	0c 96       	adiw	r24, 0x0c	; 12
     b06:	30 dc       	rcall	.-1952   	; 0x368 <uxListRemove>
     b08:	8e 01       	movw	r16, r28
     b0a:	0e 5f       	subi	r16, 0xFE	; 254
     b0c:	1f 4f       	sbci	r17, 0xFF	; 255
     b0e:	c8 01       	movw	r24, r16
     b10:	2b dc       	rcall	.-1962   	; 0x368 <uxListRemove>
     b12:	8e 89       	ldd	r24, Y+22	; 0x16
     b14:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
     b18:	98 17       	cp	r25, r24
     b1a:	10 f4       	brcc	.+4      	; 0xb20 <xTaskResumeAll+0x5c>
     b1c:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	9c 01       	movw	r18, r24
     b24:	22 0f       	add	r18, r18
     b26:	33 1f       	adc	r19, r19
     b28:	22 0f       	add	r18, r18
     b2a:	33 1f       	adc	r19, r19
     b2c:	22 0f       	add	r18, r18
     b2e:	33 1f       	adc	r19, r19
     b30:	82 0f       	add	r24, r18
     b32:	93 1f       	adc	r25, r19
     b34:	b8 01       	movw	r22, r16
     b36:	8e 55       	subi	r24, 0x5E	; 94
     b38:	99 4f       	sbci	r25, 0xF9	; 249
     b3a:	c4 db       	rcall	.-2168   	; 0x2c4 <vListInsertEnd>
     b3c:	e0 91 c6 06 	lds	r30, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     b40:	f0 91 c7 06 	lds	r31, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     b44:	9e 89       	ldd	r25, Y+22	; 0x16
     b46:	86 89       	ldd	r24, Z+22	; 0x16
     b48:	98 17       	cp	r25, r24
     b4a:	68 f0       	brcs	.+26     	; 0xb66 <xTaskResumeAll+0xa2>
     b4c:	d0 92 69 06 	sts	0x0669, r13	; 0x800669 <xYieldPending>
     b50:	0a c0       	rjmp	.+20     	; 0xb66 <xTaskResumeAll+0xa2>
     b52:	c0 e0       	ldi	r28, 0x00	; 0
     b54:	d0 e0       	ldi	r29, 0x00	; 0
     b56:	0f 2e       	mov	r0, r31
     b58:	f3 e8       	ldi	r31, 0x83	; 131
     b5a:	ef 2e       	mov	r14, r31
     b5c:	f6 e0       	ldi	r31, 0x06	; 6
     b5e:	ff 2e       	mov	r15, r31
     b60:	f0 2d       	mov	r31, r0
     b62:	dd 24       	eor	r13, r13
     b64:	d3 94       	inc	r13
     b66:	f7 01       	movw	r30, r14
     b68:	80 81       	ld	r24, Z
     b6a:	81 11       	cpse	r24, r1
     b6c:	c3 cf       	rjmp	.-122    	; 0xaf4 <xTaskResumeAll+0x30>
     b6e:	cd 2b       	or	r28, r29
     b70:	09 f0       	breq	.+2      	; 0xb74 <xTaskResumeAll+0xb0>
     b72:	3d dd       	rcall	.-1414   	; 0x5ee <prvResetNextTaskUnblockTime>
     b74:	c0 91 6a 06 	lds	r28, 0x066A	; 0x80066a <uxPendedTicks>
     b78:	cc 23       	and	r28, r28
     b7a:	49 f0       	breq	.+18     	; 0xb8e <xTaskResumeAll+0xca>
     b7c:	d1 e0       	ldi	r29, 0x01	; 1
     b7e:	06 df       	rcall	.-500    	; 0x98c <xTaskIncrementTick>
     b80:	81 11       	cpse	r24, r1
     b82:	d0 93 69 06 	sts	0x0669, r29	; 0x800669 <xYieldPending>
     b86:	c1 50       	subi	r28, 0x01	; 1
     b88:	d1 f7       	brne	.-12     	; 0xb7e <xTaskResumeAll+0xba>
     b8a:	10 92 6a 06 	sts	0x066A, r1	; 0x80066a <uxPendedTicks>
     b8e:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xYieldPending>
     b92:	0f 90       	pop	r0
     b94:	0f be       	out	0x3f, r0	; 63
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	ff 90       	pop	r15
     ba2:	ef 90       	pop	r14
     ba4:	df 90       	pop	r13
     ba6:	08 95       	ret

00000ba8 <vTaskDelay>:
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
     bac:	ec 01       	movw	r28, r24
     bae:	89 2b       	or	r24, r25
     bb0:	39 f0       	breq	.+14     	; 0xbc0 <vTaskDelay+0x18>
     bb2:	dc de       	rcall	.-584    	; 0x96c <vTaskSuspendAll>
     bb4:	60 e0       	ldi	r22, 0x00	; 0
     bb6:	ce 01       	movw	r24, r28
     bb8:	63 dd       	rcall	.-1338   	; 0x680 <prvAddCurrentTaskToDelayedList>
     bba:	84 df       	rcall	.-248    	; 0xac4 <xTaskResumeAll>
     bbc:	81 11       	cpse	r24, r1
     bbe:	01 c0       	rjmp	.+2      	; 0xbc2 <vTaskDelay+0x1a>
     bc0:	9b dc       	rcall	.-1738   	; 0x4f8 <vPortYield>
     bc2:	df 91       	pop	r29
     bc4:	cf 91       	pop	r28
     bc6:	08 95       	ret

00000bc8 <vTaskSwitchContext>:
     bc8:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     bcc:	88 23       	and	r24, r24
     bce:	21 f0       	breq	.+8      	; 0xbd8 <vTaskSwitchContext+0x10>
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <xYieldPending>
     bd6:	08 95       	ret
     bd8:	10 92 69 06 	sts	0x0669, r1	; 0x800669 <xYieldPending>
     bdc:	20 91 6c 06 	lds	r18, 0x066C	; 0x80066c <uxTopReadyPriority>
     be0:	82 2f       	mov	r24, r18
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	fc 01       	movw	r30, r24
     be6:	ee 0f       	add	r30, r30
     be8:	ff 1f       	adc	r31, r31
     bea:	ee 0f       	add	r30, r30
     bec:	ff 1f       	adc	r31, r31
     bee:	ee 0f       	add	r30, r30
     bf0:	ff 1f       	adc	r31, r31
     bf2:	e8 0f       	add	r30, r24
     bf4:	f9 1f       	adc	r31, r25
     bf6:	ee 55       	subi	r30, 0x5E	; 94
     bf8:	f9 4f       	sbci	r31, 0xF9	; 249
     bfa:	30 81       	ld	r19, Z
     bfc:	31 11       	cpse	r19, r1
     bfe:	11 c0       	rjmp	.+34     	; 0xc22 <vTaskSwitchContext+0x5a>
     c00:	21 50       	subi	r18, 0x01	; 1
     c02:	82 2f       	mov	r24, r18
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	fc 01       	movw	r30, r24
     c08:	ee 0f       	add	r30, r30
     c0a:	ff 1f       	adc	r31, r31
     c0c:	ee 0f       	add	r30, r30
     c0e:	ff 1f       	adc	r31, r31
     c10:	ee 0f       	add	r30, r30
     c12:	ff 1f       	adc	r31, r31
     c14:	e8 0f       	add	r30, r24
     c16:	f9 1f       	adc	r31, r25
     c18:	ee 55       	subi	r30, 0x5E	; 94
     c1a:	f9 4f       	sbci	r31, 0xF9	; 249
     c1c:	30 81       	ld	r19, Z
     c1e:	33 23       	and	r19, r19
     c20:	79 f3       	breq	.-34     	; 0xc00 <vTaskSwitchContext+0x38>
     c22:	ac 01       	movw	r20, r24
     c24:	44 0f       	add	r20, r20
     c26:	55 1f       	adc	r21, r21
     c28:	44 0f       	add	r20, r20
     c2a:	55 1f       	adc	r21, r21
     c2c:	44 0f       	add	r20, r20
     c2e:	55 1f       	adc	r21, r21
     c30:	48 0f       	add	r20, r24
     c32:	59 1f       	adc	r21, r25
     c34:	da 01       	movw	r26, r20
     c36:	ae 55       	subi	r26, 0x5E	; 94
     c38:	b9 4f       	sbci	r27, 0xF9	; 249
     c3a:	11 96       	adiw	r26, 0x01	; 1
     c3c:	ed 91       	ld	r30, X+
     c3e:	fc 91       	ld	r31, X
     c40:	12 97       	sbiw	r26, 0x02	; 2
     c42:	02 80       	ldd	r0, Z+2	; 0x02
     c44:	f3 81       	ldd	r31, Z+3	; 0x03
     c46:	e0 2d       	mov	r30, r0
     c48:	12 96       	adiw	r26, 0x02	; 2
     c4a:	fc 93       	st	X, r31
     c4c:	ee 93       	st	-X, r30
     c4e:	11 97       	sbiw	r26, 0x01	; 1
     c50:	4b 55       	subi	r20, 0x5B	; 91
     c52:	59 4f       	sbci	r21, 0xF9	; 249
     c54:	e4 17       	cp	r30, r20
     c56:	f5 07       	cpc	r31, r21
     c58:	29 f4       	brne	.+10     	; 0xc64 <vTaskSwitchContext+0x9c>
     c5a:	42 81       	ldd	r20, Z+2	; 0x02
     c5c:	53 81       	ldd	r21, Z+3	; 0x03
     c5e:	fd 01       	movw	r30, r26
     c60:	52 83       	std	Z+2, r21	; 0x02
     c62:	41 83       	std	Z+1, r20	; 0x01
     c64:	fc 01       	movw	r30, r24
     c66:	ee 0f       	add	r30, r30
     c68:	ff 1f       	adc	r31, r31
     c6a:	ee 0f       	add	r30, r30
     c6c:	ff 1f       	adc	r31, r31
     c6e:	ee 0f       	add	r30, r30
     c70:	ff 1f       	adc	r31, r31
     c72:	8e 0f       	add	r24, r30
     c74:	9f 1f       	adc	r25, r31
     c76:	fc 01       	movw	r30, r24
     c78:	ee 55       	subi	r30, 0x5E	; 94
     c7a:	f9 4f       	sbci	r31, 0xF9	; 249
     c7c:	01 80       	ldd	r0, Z+1	; 0x01
     c7e:	f2 81       	ldd	r31, Z+2	; 0x02
     c80:	e0 2d       	mov	r30, r0
     c82:	86 81       	ldd	r24, Z+6	; 0x06
     c84:	97 81       	ldd	r25, Z+7	; 0x07
     c86:	90 93 c7 06 	sts	0x06C7, r25	; 0x8006c7 <pxCurrentTCB+0x1>
     c8a:	80 93 c6 06 	sts	0x06C6, r24	; 0x8006c6 <pxCurrentTCB>
     c8e:	20 93 6c 06 	sts	0x066C, r18	; 0x80066c <uxTopReadyPriority>
     c92:	08 95       	ret

00000c94 <vTaskSuspend>:
     c94:	0f 93       	push	r16
     c96:	1f 93       	push	r17
     c98:	cf 93       	push	r28
     c9a:	df 93       	push	r29
     c9c:	ec 01       	movw	r28, r24
     c9e:	0f b6       	in	r0, 0x3f	; 63
     ca0:	f8 94       	cli
     ca2:	0f 92       	push	r0
     ca4:	89 2b       	or	r24, r25
     ca6:	21 f4       	brne	.+8      	; 0xcb0 <vTaskSuspend+0x1c>
     ca8:	c0 91 c6 06 	lds	r28, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     cac:	d0 91 c7 06 	lds	r29, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     cb0:	8e 01       	movw	r16, r28
     cb2:	0e 5f       	subi	r16, 0xFE	; 254
     cb4:	1f 4f       	sbci	r17, 0xFF	; 255
     cb6:	c8 01       	movw	r24, r16
     cb8:	57 db       	rcall	.-2386   	; 0x368 <uxListRemove>
     cba:	8c 89       	ldd	r24, Y+20	; 0x14
     cbc:	9d 89       	ldd	r25, Y+21	; 0x15
     cbe:	89 2b       	or	r24, r25
     cc0:	19 f0       	breq	.+6      	; 0xcc8 <vTaskSuspend+0x34>
     cc2:	ce 01       	movw	r24, r28
     cc4:	0c 96       	adiw	r24, 0x0c	; 12
     cc6:	50 db       	rcall	.-2400   	; 0x368 <uxListRemove>
     cc8:	b8 01       	movw	r22, r16
     cca:	80 e7       	ldi	r24, 0x70	; 112
     ccc:	96 e0       	ldi	r25, 0x06	; 6
     cce:	fa da       	rcall	.-2572   	; 0x2c4 <vListInsertEnd>
     cd0:	8d a1       	ldd	r24, Y+37	; 0x25
     cd2:	81 30       	cpi	r24, 0x01	; 1
     cd4:	09 f4       	brne	.+2      	; 0xcd8 <vTaskSuspend+0x44>
     cd6:	1d a2       	std	Y+37, r1	; 0x25
     cd8:	0f 90       	pop	r0
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
     ce0:	88 23       	and	r24, r24
     ce2:	31 f0       	breq	.+12     	; 0xcf0 <vTaskSuspend+0x5c>
     ce4:	0f b6       	in	r0, 0x3f	; 63
     ce6:	f8 94       	cli
     ce8:	0f 92       	push	r0
     cea:	81 dc       	rcall	.-1790   	; 0x5ee <prvResetNextTaskUnblockTime>
     cec:	0f 90       	pop	r0
     cee:	0f be       	out	0x3f, r0	; 63
     cf0:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     cf4:	90 91 c7 06 	lds	r25, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>
     cf8:	c8 17       	cp	r28, r24
     cfa:	d9 07       	cpc	r29, r25
     cfc:	91 f4       	brne	.+36     	; 0xd22 <vTaskSuspend+0x8e>
     cfe:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
     d02:	88 23       	and	r24, r24
     d04:	11 f0       	breq	.+4      	; 0xd0a <vTaskSuspend+0x76>
     d06:	f8 db       	rcall	.-2064   	; 0x4f8 <vPortYield>
     d08:	0c c0       	rjmp	.+24     	; 0xd22 <vTaskSuspend+0x8e>
     d0a:	90 91 70 06 	lds	r25, 0x0670	; 0x800670 <xSuspendedTaskList>
     d0e:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
     d12:	98 13       	cpse	r25, r24
     d14:	05 c0       	rjmp	.+10     	; 0xd20 <vTaskSuspend+0x8c>
     d16:	10 92 c7 06 	sts	0x06C7, r1	; 0x8006c7 <pxCurrentTCB+0x1>
     d1a:	10 92 c6 06 	sts	0x06C6, r1	; 0x8006c6 <pxCurrentTCB>
     d1e:	01 c0       	rjmp	.+2      	; 0xd22 <vTaskSuspend+0x8e>
     d20:	53 df       	rcall	.-346    	; 0xbc8 <vTaskSwitchContext>
     d22:	df 91       	pop	r29
     d24:	cf 91       	pop	r28
     d26:	1f 91       	pop	r17
     d28:	0f 91       	pop	r16
     d2a:	08 95       	ret

00000d2c <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
     d2c:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <pxCurrentTCB>
     d30:	90 91 c7 06 	lds	r25, 0x06C7	; 0x8006c7 <pxCurrentTCB+0x1>

		return xReturn;
	}
     d34:	08 95       	ret

00000d36 <KeyPad_getPressedKey>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
uint8_t KeyPad_getPressedKey(void)
{
     d36:	61 e0       	ldi	r22, 0x01	; 1
     d38:	e0 e0       	ldi	r30, 0x00	; 0
     d3a:	f0 e0       	ldi	r31, 0x00	; 0
	uint8_t col,row;
	uint8_t key=NO_KEY_PRESSED;
     d3c:	83 e6       	ldi	r24, 0x63	; 99
	{
		/*
		 * each time only one of the column pins will be output and
		 * the rest will be input pins include the row pins
		 */
		KEYPAD_PORT_DIR = (KEYPAD_MASK<<col);
     d3e:	a0 e1       	ldi	r26, 0x10	; 16
     d40:	b0 e0       	ldi	r27, 0x00	; 0
{
	switch(button_number)
	{
		case 10: return '*'; // ASCII Code of =
				 break;
		case 11: return 0;
     d42:	70 e0       	ldi	r23, 0x00	; 0
	{
		/*
		 * each time only one of the column pins will be output and
		 * the rest will be input pins include the row pins
		 */
		KEYPAD_PORT_DIR = (KEYPAD_MASK<<col);
     d44:	9d 01       	movw	r18, r26
     d46:	0e 2e       	mov	r0, r30
     d48:	02 c0       	rjmp	.+4      	; 0xd4e <KeyPad_getPressedKey+0x18>
     d4a:	22 0f       	add	r18, r18
     d4c:	33 1f       	adc	r19, r19
     d4e:	0a 94       	dec	r0
     d50:	e2 f7       	brpl	.-8      	; 0xd4a <KeyPad_getPressedKey+0x14>
     d52:	24 bb       	out	0x14, r18	; 20

		/*
		 * clear the output pin column in this trace and enable the internal
		 * pull up resistors for the rows pins
		 */
		KEYPAD_PORT_OUT = (~(KEYPAD_MASK<<col));
     d54:	20 95       	com	r18
     d56:	25 bb       	out	0x15, r18	; 21
     d58:	96 2f       	mov	r25, r22
     d5a:	40 e0       	ldi	r20, 0x00	; 0
     d5c:	50 e0       	ldi	r21, 0x00	; 0
		for(row=INITIAL_VALUE;row<N_row;row++) /* loop for rows */
		{
			if(BIT_IS_CLEAR(KEYPAD_PORT_IN,row)) /* if the switch is press in this row */
     d5e:	23 b3       	in	r18, 0x13	; 19
     d60:	30 e0       	ldi	r19, 0x00	; 0
     d62:	04 2e       	mov	r0, r20
     d64:	02 c0       	rjmp	.+4      	; 0xd6a <KeyPad_getPressedKey+0x34>
     d66:	35 95       	asr	r19
     d68:	27 95       	ror	r18
     d6a:	0a 94       	dec	r0
     d6c:	e2 f7       	brpl	.-8      	; 0xd66 <KeyPad_getPressedKey+0x30>
     d6e:	20 fd       	sbrc	r18, 0
     d70:	0e c0       	rjmp	.+28     	; 0xd8e <KeyPad_getPressedKey+0x58>



static uint8_t KeyPad_4x3_adjustKeyNumber(uint8_t button_number)
{
	switch(button_number)
     d72:	9b 30       	cpi	r25, 0x0B	; 11
     d74:	29 f0       	breq	.+10     	; 0xd80 <KeyPad_getPressedKey+0x4a>
     d76:	9c 30       	cpi	r25, 0x0C	; 12
     d78:	29 f0       	breq	.+10     	; 0xd84 <KeyPad_getPressedKey+0x4e>
     d7a:	9a 30       	cpi	r25, 0x0A	; 10
     d7c:	29 f4       	brne	.+10     	; 0xd88 <KeyPad_getPressedKey+0x52>
     d7e:	06 c0       	rjmp	.+12     	; 0xd8c <KeyPad_getPressedKey+0x56>
	{
		case 10: return '*'; // ASCII Code of =
				 break;
		case 11: return 0;
     d80:	87 2f       	mov	r24, r23
     d82:	05 c0       	rjmp	.+10     	; 0xd8e <KeyPad_getPressedKey+0x58>
				 break;
		case 12: return '#'; // ASCII Code of +
     d84:	83 e2       	ldi	r24, 0x23	; 35
     d86:	03 c0       	rjmp	.+6      	; 0xd8e <KeyPad_getPressedKey+0x58>
				 break;
		default: return button_number;
     d88:	89 2f       	mov	r24, r25
     d8a:	01 c0       	rjmp	.+2      	; 0xd8e <KeyPad_getPressedKey+0x58>

static uint8_t KeyPad_4x3_adjustKeyNumber(uint8_t button_number)
{
	switch(button_number)
	{
		case 10: return '*'; // ASCII Code of =
     d8c:	8a e2       	ldi	r24, 0x2A	; 42
     d8e:	4f 5f       	subi	r20, 0xFF	; 255
     d90:	5f 4f       	sbci	r21, 0xFF	; 255
     d92:	9d 5f       	subi	r25, 0xFD	; 253
		/*
		 * clear the output pin column in this trace and enable the internal
		 * pull up resistors for the rows pins
		 */
		KEYPAD_PORT_OUT = (~(KEYPAD_MASK<<col));
		for(row=INITIAL_VALUE;row<N_row;row++) /* loop for rows */
     d94:	44 30       	cpi	r20, 0x04	; 4
     d96:	51 05       	cpc	r21, r1
     d98:	11 f7       	brne	.-60     	; 0xd5e <KeyPad_getPressedKey+0x28>
     d9a:	31 96       	adiw	r30, 0x01	; 1
     d9c:	6f 5f       	subi	r22, 0xFF	; 255
 *******************************************************************************/
uint8_t KeyPad_getPressedKey(void)
{
	uint8_t col,row;
	uint8_t key=NO_KEY_PRESSED;
	for(col=INITIAL_VALUE;col<N_col;col++) /* loop for columns */
     d9e:	64 30       	cpi	r22, 0x04	; 4
     da0:	89 f6       	brne	.-94     	; 0xd44 <KeyPad_getPressedKey+0xe>

			}
		}
	}
	return key;
}
     da2:	08 95       	ret

00000da4 <LCD_sendCommand>:

void LCD_displayStringRowColumn(uint8_t row,uint8_t col,const char *Str)
{
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
	LCD_displayString(Str); /* display the string */
}
     da4:	cf 93       	push	r28
     da6:	c8 2f       	mov	r28, r24
     da8:	d9 98       	cbi	0x1b, 1	; 27
     daa:	da 98       	cbi	0x1b, 2	; 27
     dac:	db 9a       	sbi	0x1b, 3	; 27
     dae:	8b b3       	in	r24, 0x1b	; 27
     db0:	8f 70       	andi	r24, 0x0F	; 15
     db2:	9c 2f       	mov	r25, r28
     db4:	90 7f       	andi	r25, 0xF0	; 240
     db6:	89 2b       	or	r24, r25
     db8:	8b bb       	out	0x1b, r24	; 27
     dba:	63 e0       	ldi	r22, 0x03	; 3
     dbc:	70 e0       	ldi	r23, 0x00	; 0
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	20 da       	rcall	.-3008   	; 0x204 <softwareDelayus>
     dc4:	db 98       	cbi	0x1b, 3	; 27
     dc6:	63 e0       	ldi	r22, 0x03	; 3
     dc8:	70 e0       	ldi	r23, 0x00	; 0
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	1a da       	rcall	.-3020   	; 0x204 <softwareDelayus>
     dd0:	db 9a       	sbi	0x1b, 3	; 27
     dd2:	63 e0       	ldi	r22, 0x03	; 3
     dd4:	70 e0       	ldi	r23, 0x00	; 0
     dd6:	80 e0       	ldi	r24, 0x00	; 0
     dd8:	90 e0       	ldi	r25, 0x00	; 0
     dda:	14 da       	rcall	.-3032   	; 0x204 <softwareDelayus>
     ddc:	8b b3       	in	r24, 0x1b	; 27
     dde:	28 2f       	mov	r18, r24
     de0:	2f 70       	andi	r18, 0x0F	; 15
     de2:	30 e1       	ldi	r19, 0x10	; 16
     de4:	c3 9f       	mul	r28, r19
     de6:	c0 01       	movw	r24, r0
     de8:	11 24       	eor	r1, r1
     dea:	82 2b       	or	r24, r18
     dec:	8b bb       	out	0x1b, r24	; 27
     dee:	63 e0       	ldi	r22, 0x03	; 3
     df0:	70 e0       	ldi	r23, 0x00	; 0
     df2:	80 e0       	ldi	r24, 0x00	; 0
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	06 da       	rcall	.-3060   	; 0x204 <softwareDelayus>
     df8:	db 98       	cbi	0x1b, 3	; 27
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	80 93 df 06 	sts	0x06DF, r24	; 0x8006df <gu8_SendCommand_CompleteFlag>
     e00:	cf 91       	pop	r28
     e02:	08 95       	ret

00000e04 <LCD_init>:
     e04:	8a b3       	in	r24, 0x1a	; 26
     e06:	8e 60       	ori	r24, 0x0E	; 14
     e08:	8a bb       	out	0x1a, r24	; 26
     e0a:	8a b3       	in	r24, 0x1a	; 26
     e0c:	80 6f       	ori	r24, 0xF0	; 240
     e0e:	8a bb       	out	0x1a, r24	; 26
     e10:	82 e0       	ldi	r24, 0x02	; 2
     e12:	c8 df       	rcall	.-112    	; 0xda4 <LCD_sendCommand>
     e14:	88 e2       	ldi	r24, 0x28	; 40
     e16:	c6 df       	rcall	.-116    	; 0xda4 <LCD_sendCommand>
     e18:	8c e0       	ldi	r24, 0x0C	; 12
     e1a:	c4 df       	rcall	.-120    	; 0xda4 <LCD_sendCommand>
     e1c:	81 e0       	ldi	r24, 0x01	; 1
     e1e:	c2 df       	rcall	.-124    	; 0xda4 <LCD_sendCommand>
     e20:	10 92 de 06 	sts	0x06DE, r1	; 0x8006de <gu8_LCDInit_CompleteFlag>
     e24:	10 92 df 06 	sts	0x06DF, r1	; 0x8006df <gu8_SendCommand_CompleteFlag>
     e28:	10 92 dd 06 	sts	0x06DD, r1	; 0x8006dd <gu8_SendChar_CompleteFlag>
     e2c:	10 92 dc 06 	sts	0x06DC, r1	; 0x8006dc <gu8_String_CompleteFlag>
     e30:	08 95       	ret

00000e32 <LCD_displayCharacter>:
     e32:	cf 93       	push	r28
     e34:	c8 2f       	mov	r28, r24
     e36:	80 91 df 06 	lds	r24, 0x06DF	; 0x8006df <gu8_SendCommand_CompleteFlag>
     e3a:	81 30       	cpi	r24, 0x01	; 1
     e3c:	39 f4       	brne	.+14     	; 0xe4c <LCD_displayCharacter+0x1a>
     e3e:	10 92 df 06 	sts	0x06DF, r1	; 0x8006df <gu8_SendCommand_CompleteFlag>
     e42:	60 e5       	ldi	r22, 0x50	; 80
     e44:	70 e0       	ldi	r23, 0x00	; 0
     e46:	80 e0       	ldi	r24, 0x00	; 0
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	dc d9       	rcall	.-3144   	; 0x204 <softwareDelayus>
     e4c:	d9 9a       	sbi	0x1b, 1	; 27
     e4e:	da 98       	cbi	0x1b, 2	; 27
     e50:	61 e0       	ldi	r22, 0x01	; 1
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	d5 d9       	rcall	.-3158   	; 0x204 <softwareDelayus>
     e5a:	db 9a       	sbi	0x1b, 3	; 27
     e5c:	61 e0       	ldi	r22, 0x01	; 1
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	80 e0       	ldi	r24, 0x00	; 0
     e62:	90 e0       	ldi	r25, 0x00	; 0
     e64:	cf d9       	rcall	.-3170   	; 0x204 <softwareDelayus>
     e66:	8b b3       	in	r24, 0x1b	; 27
     e68:	8f 70       	andi	r24, 0x0F	; 15
     e6a:	9c 2f       	mov	r25, r28
     e6c:	90 7f       	andi	r25, 0xF0	; 240
     e6e:	89 2b       	or	r24, r25
     e70:	8b bb       	out	0x1b, r24	; 27
     e72:	63 e0       	ldi	r22, 0x03	; 3
     e74:	70 e0       	ldi	r23, 0x00	; 0
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	c4 d9       	rcall	.-3192   	; 0x204 <softwareDelayus>
     e7c:	db 98       	cbi	0x1b, 3	; 27
     e7e:	63 e0       	ldi	r22, 0x03	; 3
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	80 e0       	ldi	r24, 0x00	; 0
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	be d9       	rcall	.-3204   	; 0x204 <softwareDelayus>
     e88:	db 9a       	sbi	0x1b, 3	; 27
     e8a:	63 e0       	ldi	r22, 0x03	; 3
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 e0       	ldi	r24, 0x00	; 0
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	b8 d9       	rcall	.-3216   	; 0x204 <softwareDelayus>
     e94:	8b b3       	in	r24, 0x1b	; 27
     e96:	28 2f       	mov	r18, r24
     e98:	2f 70       	andi	r18, 0x0F	; 15
     e9a:	30 e1       	ldi	r19, 0x10	; 16
     e9c:	c3 9f       	mul	r28, r19
     e9e:	c0 01       	movw	r24, r0
     ea0:	11 24       	eor	r1, r1
     ea2:	82 2b       	or	r24, r18
     ea4:	8b bb       	out	0x1b, r24	; 27
     ea6:	63 e0       	ldi	r22, 0x03	; 3
     ea8:	70 e0       	ldi	r23, 0x00	; 0
     eaa:	80 e0       	ldi	r24, 0x00	; 0
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	aa d9       	rcall	.-3244   	; 0x204 <softwareDelayus>
     eb0:	db 98       	cbi	0x1b, 3	; 27
     eb2:	61 e0       	ldi	r22, 0x01	; 1
     eb4:	70 e0       	ldi	r23, 0x00	; 0
     eb6:	80 e0       	ldi	r24, 0x00	; 0
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	a4 d9       	rcall	.-3256   	; 0x204 <softwareDelayus>
     ebc:	cf 91       	pop	r28
     ebe:	08 95       	ret

00000ec0 <LCD_goToRowColumn>:
     ec0:	81 30       	cpi	r24, 0x01	; 1
     ec2:	41 f0       	breq	.+16     	; 0xed4 <LCD_goToRowColumn+0x14>
     ec4:	28 f0       	brcs	.+10     	; 0xed0 <LCD_goToRowColumn+0x10>
     ec6:	82 30       	cpi	r24, 0x02	; 2
     ec8:	41 f0       	breq	.+16     	; 0xeda <LCD_goToRowColumn+0x1a>
     eca:	83 30       	cpi	r24, 0x03	; 3
     ecc:	49 f0       	breq	.+18     	; 0xee0 <LCD_goToRowColumn+0x20>
     ece:	0a c0       	rjmp	.+20     	; 0xee4 <LCD_goToRowColumn+0x24>
     ed0:	96 2f       	mov	r25, r22
     ed2:	08 c0       	rjmp	.+16     	; 0xee4 <LCD_goToRowColumn+0x24>
     ed4:	90 e4       	ldi	r25, 0x40	; 64
     ed6:	96 0f       	add	r25, r22
     ed8:	05 c0       	rjmp	.+10     	; 0xee4 <LCD_goToRowColumn+0x24>
     eda:	90 e1       	ldi	r25, 0x10	; 16
     edc:	96 0f       	add	r25, r22
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <LCD_goToRowColumn+0x24>
     ee0:	90 e5       	ldi	r25, 0x50	; 80
     ee2:	96 0f       	add	r25, r22
     ee4:	89 2f       	mov	r24, r25
     ee6:	80 68       	ori	r24, 0x80	; 128
     ee8:	5d cf       	rjmp	.-326    	; 0xda4 <LCD_sendCommand>
     eea:	08 95       	ret

00000eec <LCD_clearScreen>:

void LCD_clearScreen(void)
{
	LCD_sendCommand(CLEAR_COMMAND); //clear display
     eec:	81 e0       	ldi	r24, 0x01	; 1
     eee:	5a cf       	rjmp	.-332    	; 0xda4 <LCD_sendCommand>
     ef0:	08 95       	ret

00000ef2 <Led_Init>:

/******************************global variables*****************************/

/***************************************************************************/
void Led_Init(En_LedNumber_t en_led_id)
{
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	00 d0       	rcall	.+0      	; 0xef8 <Led_Init+0x6>
     ef8:	1f 92       	push	r1
     efa:	cd b7       	in	r28, 0x3d	; 61
     efc:	de b7       	in	r29, 0x3e	; 62
	DIO_Cfg_s LED_init;
	switch(en_led_id)
     efe:	81 30       	cpi	r24, 0x01	; 1
     f00:	69 f0       	breq	.+26     	; 0xf1c <Led_Init+0x2a>
     f02:	28 f0       	brcs	.+10     	; 0xf0e <Led_Init+0x1c>
     f04:	82 30       	cpi	r24, 0x02	; 2
     f06:	89 f0       	breq	.+34     	; 0xf2a <Led_Init+0x38>
     f08:	83 30       	cpi	r24, 0x03	; 3
     f0a:	b1 f0       	breq	.+44     	; 0xf38 <Led_Init+0x46>
     f0c:	1b c0       	rjmp	.+54     	; 0xf44 <Led_Init+0x52>
	{
	case LED_0:
		LED_init.GPIO=LED_0_GPIO;
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	89 83       	std	Y+1, r24	; 0x01
		LED_init.pins=LED_0_BIT;
     f12:	80 e1       	ldi	r24, 0x10	; 16
     f14:	8a 83       	std	Y+2, r24	; 0x02
		LED_init.dir=OUTPUT;
     f16:	8f ef       	ldi	r24, 0xFF	; 255
     f18:	8b 83       	std	Y+3, r24	; 0x03
		break;
     f1a:	14 c0       	rjmp	.+40     	; 0xf44 <Led_Init+0x52>
	case LED_1:
		LED_init.GPIO=LED_1_GPIO;
     f1c:	81 e0       	ldi	r24, 0x01	; 1
     f1e:	89 83       	std	Y+1, r24	; 0x01
		LED_init.pins=LED_1_BIT;
     f20:	80 e2       	ldi	r24, 0x20	; 32
     f22:	8a 83       	std	Y+2, r24	; 0x02
		LED_init.dir=OUTPUT;
     f24:	8f ef       	ldi	r24, 0xFF	; 255
     f26:	8b 83       	std	Y+3, r24	; 0x03
		break;
     f28:	0d c0       	rjmp	.+26     	; 0xf44 <Led_Init+0x52>
	case LED_2:
		LED_init.GPIO=LED_2_GPIO;
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	89 83       	std	Y+1, r24	; 0x01
		LED_init.pins=LED_2_BIT;
     f2e:	80 e4       	ldi	r24, 0x40	; 64
     f30:	8a 83       	std	Y+2, r24	; 0x02
		LED_init.dir=OUTPUT;
     f32:	8f ef       	ldi	r24, 0xFF	; 255
     f34:	8b 83       	std	Y+3, r24	; 0x03
		break;
     f36:	06 c0       	rjmp	.+12     	; 0xf44 <Led_Init+0x52>
	case LED_3:
		LED_init.GPIO=LED_3_GPIO;
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	89 83       	std	Y+1, r24	; 0x01
		LED_init.pins=LED_3_BIT;
     f3c:	80 e8       	ldi	r24, 0x80	; 128
     f3e:	8a 83       	std	Y+2, r24	; 0x02
		LED_init.dir=OUTPUT;
     f40:	8f ef       	ldi	r24, 0xFF	; 255
     f42:	8b 83       	std	Y+3, r24	; 0x03
		break;

	}
	DIO_init(&LED_init);
     f44:	ce 01       	movw	r24, r28
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	b5 d0       	rcall	.+362    	; 0x10b4 <DIO_init>
}
     f4a:	0f 90       	pop	r0
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	df 91       	pop	r29
     f52:	cf 91       	pop	r28
     f54:	08 95       	ret

00000f56 <Led_On>:

void Led_On(En_LedNumber_t en_led_id)
{
	switch(en_led_id)
     f56:	81 30       	cpi	r24, 0x01	; 1
     f58:	59 f0       	breq	.+22     	; 0xf70 <Led_On+0x1a>
     f5a:	28 f0       	brcs	.+10     	; 0xf66 <Led_On+0x10>
     f5c:	82 30       	cpi	r24, 0x02	; 2
     f5e:	69 f0       	breq	.+26     	; 0xf7a <Led_On+0x24>
     f60:	83 30       	cpi	r24, 0x03	; 3
     f62:	81 f0       	breq	.+32     	; 0xf84 <Led_On+0x2e>
     f64:	08 95       	ret
	{
	case LED_0:
		DIO_Write(LED_0_GPIO, LED_0_BIT, HIGH);
     f66:	4f ef       	ldi	r20, 0xFF	; 255
     f68:	60 e1       	ldi	r22, 0x10	; 16
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	04 c1       	rjmp	.+520    	; 0x1176 <DIO_Write>
		break;
     f6e:	08 95       	ret
	case LED_1:
		DIO_Write(LED_1_GPIO, LED_1_BIT, HIGH);
     f70:	4f ef       	ldi	r20, 0xFF	; 255
     f72:	60 e2       	ldi	r22, 0x20	; 32
     f74:	81 e0       	ldi	r24, 0x01	; 1
     f76:	ff c0       	rjmp	.+510    	; 0x1176 <DIO_Write>
		break;
     f78:	08 95       	ret
	case LED_2:
		DIO_Write(LED_2_GPIO, LED_2_BIT, HIGH);
     f7a:	4f ef       	ldi	r20, 0xFF	; 255
     f7c:	60 e4       	ldi	r22, 0x40	; 64
     f7e:	81 e0       	ldi	r24, 0x01	; 1
     f80:	fa c0       	rjmp	.+500    	; 0x1176 <DIO_Write>
		break;
     f82:	08 95       	ret
	case LED_3:
		DIO_Write(LED_3_GPIO, LED_3_BIT, HIGH);
     f84:	4f ef       	ldi	r20, 0xFF	; 255
     f86:	60 e8       	ldi	r22, 0x80	; 128
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	f5 c0       	rjmp	.+490    	; 0x1176 <DIO_Write>
     f8c:	08 95       	ret

00000f8e <Led_Off>:
	}
}

void Led_Off(En_LedNumber_t en_led_id)
{
	switch(en_led_id)
     f8e:	81 30       	cpi	r24, 0x01	; 1
     f90:	59 f0       	breq	.+22     	; 0xfa8 <Led_Off+0x1a>
     f92:	28 f0       	brcs	.+10     	; 0xf9e <Led_Off+0x10>
     f94:	82 30       	cpi	r24, 0x02	; 2
     f96:	69 f0       	breq	.+26     	; 0xfb2 <Led_Off+0x24>
     f98:	83 30       	cpi	r24, 0x03	; 3
     f9a:	81 f0       	breq	.+32     	; 0xfbc <Led_Off+0x2e>
     f9c:	08 95       	ret
	{
	case LED_0:
		DIO_Write(LED_0_GPIO, LED_0_BIT, LOW);
     f9e:	40 e0       	ldi	r20, 0x00	; 0
     fa0:	60 e1       	ldi	r22, 0x10	; 16
     fa2:	81 e0       	ldi	r24, 0x01	; 1
     fa4:	e8 c0       	rjmp	.+464    	; 0x1176 <DIO_Write>
		break;
     fa6:	08 95       	ret
	case LED_1:
		DIO_Write(LED_1_GPIO, LED_1_BIT, LOW);
     fa8:	40 e0       	ldi	r20, 0x00	; 0
     faa:	60 e2       	ldi	r22, 0x20	; 32
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	e3 c0       	rjmp	.+454    	; 0x1176 <DIO_Write>
		break;
     fb0:	08 95       	ret
	case LED_2:
		DIO_Write(LED_2_GPIO, LED_2_BIT, LOW);
     fb2:	40 e0       	ldi	r20, 0x00	; 0
     fb4:	60 e4       	ldi	r22, 0x40	; 64
     fb6:	81 e0       	ldi	r24, 0x01	; 1
     fb8:	de c0       	rjmp	.+444    	; 0x1176 <DIO_Write>
		break;
     fba:	08 95       	ret
	case LED_3:
		DIO_Write(LED_3_GPIO, LED_3_BIT, LOW);
     fbc:	40 e0       	ldi	r20, 0x00	; 0
     fbe:	60 e8       	ldi	r22, 0x80	; 128
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	d9 c0       	rjmp	.+434    	; 0x1176 <DIO_Write>
     fc4:	08 95       	ret

00000fc6 <pushButtonInit>:
#include "pushButton.h"
ERROR_STATUS pushButtonInit(uint8_t en_butotn_id)
{
     fc6:	cf 93       	push	r28
     fc8:	df 93       	push	r29
     fca:	00 d0       	rcall	.+0      	; 0xfcc <pushButtonInit+0x6>
     fcc:	1f 92       	push	r1
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
	ERROR_STATUS ERR = E_OK;
	DIO_Cfg_s btn;

	switch(en_butotn_id){
     fd2:	88 23       	and	r24, r24
     fd4:	19 f0       	breq	.+6      	; 0xfdc <pushButtonInit+0x16>
     fd6:	81 30       	cpi	r24, 0x01	; 1
     fd8:	39 f0       	breq	.+14     	; 0xfe8 <pushButtonInit+0x22>
     fda:	0b c0       	rjmp	.+22     	; 0xff2 <pushButtonInit+0x2c>
		case BTN_0:
		btn.GPIO = BTN_0_GPIO;
     fdc:	82 e0       	ldi	r24, 0x02	; 2
     fde:	89 83       	std	Y+1, r24	; 0x01
		btn.pins = BIT4;
     fe0:	80 e1       	ldi	r24, 0x10	; 16
     fe2:	8a 83       	std	Y+2, r24	; 0x02
		btn.dir = INPUT;
     fe4:	1b 82       	std	Y+3, r1	; 0x03
		break;
     fe6:	05 c0       	rjmp	.+10     	; 0xff2 <pushButtonInit+0x2c>
		case BTN_1:
		btn.GPIO = BTN_1_GPIO;
     fe8:	83 e0       	ldi	r24, 0x03	; 3
     fea:	89 83       	std	Y+1, r24	; 0x01
		btn.pins = BIT2;
     fec:	84 e0       	ldi	r24, 0x04	; 4
     fee:	8a 83       	std	Y+2, r24	; 0x02
		btn.dir = INPUT;
     ff0:	1b 82       	std	Y+3, r1	; 0x03
		break;
		default:
		break;
	}
	DIO_init (&btn);
     ff2:	ce 01       	movw	r24, r28
     ff4:	01 96       	adiw	r24, 0x01	; 1
     ff6:	5e d0       	rcall	.+188    	; 0x10b4 <DIO_init>
	DIO_Write(btn.GPIO,btn.pins,HIGH);
     ff8:	4f ef       	ldi	r20, 0xFF	; 255
     ffa:	6a 81       	ldd	r22, Y+2	; 0x02
     ffc:	89 81       	ldd	r24, Y+1	; 0x01
     ffe:	bb d0       	rcall	.+374    	; 0x1176 <DIO_Write>
	return ERR;
}
    1000:	80 e0       	ldi	r24, 0x00	; 0
    1002:	0f 90       	pop	r0
    1004:	0f 90       	pop	r0
    1006:	0f 90       	pop	r0
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	08 95       	ret

0000100e <pushButtonGetStatus>:


ERROR_STATUS pushButtonGetStatus(uint8_t BTN , uint8_t * au8_button_status)
{
    100e:	cf 93       	push	r28
    1010:	df 93       	push	r29
    1012:	eb 01       	movw	r28, r22
	uint8_t status = E_OK;
	switch(BTN){
    1014:	88 23       	and	r24, r24
    1016:	19 f0       	breq	.+6      	; 0x101e <pushButtonGetStatus+0x10>
    1018:	81 30       	cpi	r24, 0x01	; 1
    101a:	39 f0       	breq	.+14     	; 0x102a <pushButtonGetStatus+0x1c>
    101c:	0c c0       	rjmp	.+24     	; 0x1036 <pushButtonGetStatus+0x28>
		case BTN_0:
		DIO_Read( BTN_0_GPIO, BTN_0_BIT,au8_button_status);
    101e:	ab 01       	movw	r20, r22
    1020:	64 e0       	ldi	r22, 0x04	; 4
    1022:	82 e0       	ldi	r24, 0x02	; 2
    1024:	f6 d0       	rcall	.+492    	; 0x1212 <DIO_Read>
}


ERROR_STATUS pushButtonGetStatus(uint8_t BTN , uint8_t * au8_button_status)
{
	uint8_t status = E_OK;
    1026:	80 e0       	ldi	r24, 0x00	; 0
	switch(BTN){
		case BTN_0:
		DIO_Read( BTN_0_GPIO, BTN_0_BIT,au8_button_status);
		break;
    1028:	07 c0       	rjmp	.+14     	; 0x1038 <pushButtonGetStatus+0x2a>
		case BTN_1:
		DIO_Read( BTN_1_GPIO, BTN_1_BIT,au8_button_status);
    102a:	ab 01       	movw	r20, r22
    102c:	62 e0       	ldi	r22, 0x02	; 2
    102e:	83 e0       	ldi	r24, 0x03	; 3
    1030:	f0 d0       	rcall	.+480    	; 0x1212 <DIO_Read>
}


ERROR_STATUS pushButtonGetStatus(uint8_t BTN , uint8_t * au8_button_status)
{
	uint8_t status = E_OK;
    1032:	80 e0       	ldi	r24, 0x00	; 0
		case BTN_0:
		DIO_Read( BTN_0_GPIO, BTN_0_BIT,au8_button_status);
		break;
		case BTN_1:
		DIO_Read( BTN_1_GPIO, BTN_1_BIT,au8_button_status);
		break;
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <pushButtonGetStatus+0x2a>
		default:
		status = E_NOK;
    1036:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
	 	if(*au8_button_status==0){
    1038:	98 81       	ld	r25, Y
    103a:	91 11       	cpse	r25, r1
    103c:	02 c0       	rjmp	.+4      	; 0x1042 <pushButtonGetStatus+0x34>
	 		*au8_button_status = Pressed;
    103e:	18 82       	st	Y, r1
    1040:	02 c0       	rjmp	.+4      	; 0x1046 <pushButtonGetStatus+0x38>
	 	}else{
			*au8_button_status = Released;
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	98 83       	st	Y, r25
	 	}
	return status;
    1046:	df 91       	pop	r29
    1048:	cf 91       	pop	r28
    104a:	08 95       	ret

0000104c <vOtherFunction>:



/* Function that creates a task. */
void vOtherFunction( void )
{
    104c:	ef 92       	push	r14
    104e:	ff 92       	push	r15
    1050:	0f 93       	push	r16
    1052:	cf 93       	push	r28
    1054:	df 93       	push	r29
    1056:	00 d0       	rcall	.+0      	; 0x1058 <vOtherFunction+0xc>
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62

TaskHandle_t xHandle = NULL;
    105c:	1a 82       	std	Y+2, r1	; 0x02
    105e:	19 82       	std	Y+1, r1	; 0x01

    /* Create the task, storing the handle. */
    xTaskCreate(UserStoryOneInit,       /* Function that implements the task. */
    1060:	ce 01       	movw	r24, r28
    1062:	01 96       	adiw	r24, 0x01	; 1
    1064:	7c 01       	movw	r14, r24
    1066:	00 e0       	ldi	r16, 0x00	; 0
    1068:	21 e0       	ldi	r18, 0x01	; 1
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	44 e6       	ldi	r20, 0x64	; 100
    106e:	50 e0       	ldi	r21, 0x00	; 0
    1070:	65 e6       	ldi	r22, 0x65	; 101
    1072:	70 e0       	ldi	r23, 0x00	; 0
    1074:	88 e4       	ldi	r24, 0x48	; 72
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	57 db       	rcall	.-2386   	; 0x728 <xTaskCreate>
                    STACK_SIZE,      /* Stack size in words, not bytes. */
                    ( void * ) 1,    /* Parameter passed into the task. */
                    tskIDLE_PRIORITY,/* Priority at which the task is created. */
                    &xHandle );      /* Used to pass out the created task's handle. */

 xTaskCreate(
    107a:	21 e0       	ldi	r18, 0x01	; 1
    107c:	30 e0       	ldi	r19, 0x00	; 0
    107e:	44 e6       	ldi	r20, 0x64	; 100
    1080:	50 e0       	ldi	r21, 0x00	; 0
    1082:	6a e6       	ldi	r22, 0x6A	; 106
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	88 e7       	ldi	r24, 0x78	; 120
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	4e db       	rcall	.-2404   	; 0x728 <xTaskCreate>
 ( void * ) 1,    /* Parameter passed into the task. */
 tskIDLE_PRIORITY,/* Priority at which the task is created. */
 &xHandle );      /* Used to pass out the created task's handle. */
 
 
  xTaskCreate(
    108c:	21 e0       	ldi	r18, 0x01	; 1
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	44 e6       	ldi	r20, 0x64	; 100
    1092:	50 e0       	ldi	r21, 0x00	; 0
    1094:	64 e7       	ldi	r22, 0x74	; 116
    1096:	70 e0       	ldi	r23, 0x00	; 0
    1098:	84 eb       	ldi	r24, 0xB4	; 180
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	45 db       	rcall	.-2422   	; 0x728 <xTaskCreate>
  STACK_SIZE,      /* Stack size in words, not bytes. */
  ( void * ) 1,    /* Parameter passed into the task. */
  tskIDLE_PRIORITY,/* Priority at which the task is created. */
  &xHandle );      /* Used to pass out the created task's handle. */

}
    109e:	0f 90       	pop	r0
    10a0:	0f 90       	pop	r0
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	0f 91       	pop	r16
    10a8:	ff 90       	pop	r15
    10aa:	ef 90       	pop	r14
    10ac:	08 95       	ret

000010ae <main>:
void vTaskCode( void * pvParameters );

int main(void)
{

	 vOtherFunction();
    10ae:	ce df       	rcall	.-100    	; 0x104c <vOtherFunction>
	/*start scheduler*/
	vTaskStartScheduler();
    10b0:	35 dc       	rcall	.-1942   	; 0x91c <vTaskStartScheduler>
    10b2:	ff cf       	rjmp	.-2      	; 0x10b2 <main+0x4>

000010b4 <DIO_init>:
    10b4:	fc 01       	movw	r30, r24
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
 /*check if the pointer is not null*/  
   if(DIO_info!=NULL)
    10b6:	89 2b       	or	r24, r25
    10b8:	09 f4       	brne	.+2      	; 0x10bc <DIO_init+0x8>
    10ba:	51 c0       	rjmp	.+162    	; 0x115e <DIO_init+0xaa>
   {
 /*choose any PORT*/ 
      switch(DIO_info->GPIO)
    10bc:	80 81       	ld	r24, Z
    10be:	81 30       	cpi	r24, 0x01	; 1
    10c0:	c1 f0       	breq	.+48     	; 0x10f2 <DIO_init+0x3e>
    10c2:	28 f0       	brcs	.+10     	; 0x10ce <DIO_init+0x1a>
    10c4:	82 30       	cpi	r24, 0x02	; 2
    10c6:	39 f1       	breq	.+78     	; 0x1116 <DIO_init+0x62>
    10c8:	83 30       	cpi	r24, 0x03	; 3
    10ca:	b9 f1       	breq	.+110    	; 0x113a <DIO_init+0x86>
    10cc:	4a c0       	rjmp	.+148    	; 0x1162 <DIO_init+0xae>
      {
         case GPIOA:
               if(DIO_info->dir==OUTPUT)
    10ce:	82 81       	ldd	r24, Z+2	; 0x02
    10d0:	8f 3f       	cpi	r24, 0xFF	; 255
    10d2:	31 f4       	brne	.+12     	; 0x10e0 <DIO_init+0x2c>
               PORTA_DIR|=(DIO_info->pins);
    10d4:	9a b3       	in	r25, 0x1a	; 26
    10d6:	81 81       	ldd	r24, Z+1	; 0x01
    10d8:	89 2b       	or	r24, r25
    10da:	8a bb       	out	0x1a, r24	; 26
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    10dc:	80 e0       	ldi	r24, 0x00	; 0
    10de:	08 95       	ret
      switch(DIO_info->GPIO)
      {
         case GPIOA:
               if(DIO_info->dir==OUTPUT)
               PORTA_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
    10e0:	81 11       	cpse	r24, r1
    10e2:	41 c0       	rjmp	.+130    	; 0x1166 <DIO_init+0xb2>
               PORTA_DIR&=~(DIO_info->pins);
    10e4:	9a b3       	in	r25, 0x1a	; 26
    10e6:	81 81       	ldd	r24, Z+1	; 0x01
    10e8:	80 95       	com	r24
    10ea:	89 23       	and	r24, r25
    10ec:	8a bb       	out	0x1a, r24	; 26
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	08 95       	ret
               PORTA_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
               break;
         case GPIOB:
               if(DIO_info->dir==OUTPUT)
    10f2:	82 81       	ldd	r24, Z+2	; 0x02
    10f4:	8f 3f       	cpi	r24, 0xFF	; 255
    10f6:	31 f4       	brne	.+12     	; 0x1104 <DIO_init+0x50>
               PORTB_DIR|=(DIO_info->pins);
    10f8:	97 b3       	in	r25, 0x17	; 23
    10fa:	81 81       	ldd	r24, Z+1	; 0x01
    10fc:	89 2b       	or	r24, r25
    10fe:	87 bb       	out	0x17, r24	; 23
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	08 95       	ret
               EROR=E_NOK;
               break;
         case GPIOB:
               if(DIO_info->dir==OUTPUT)
               PORTB_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
    1104:	81 11       	cpse	r24, r1
    1106:	31 c0       	rjmp	.+98     	; 0x116a <DIO_init+0xb6>
               PORTB_DIR&=~(DIO_info->pins);
    1108:	97 b3       	in	r25, 0x17	; 23
    110a:	81 81       	ldd	r24, Z+1	; 0x01
    110c:	80 95       	com	r24
    110e:	89 23       	and	r24, r25
    1110:	87 bb       	out	0x17, r24	; 23
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	08 95       	ret
               PORTB_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
               break;
         case GPIOC:
               if(DIO_info->dir==OUTPUT)
    1116:	82 81       	ldd	r24, Z+2	; 0x02
    1118:	8f 3f       	cpi	r24, 0xFF	; 255
    111a:	31 f4       	brne	.+12     	; 0x1128 <DIO_init+0x74>
               PORTC_DIR|=(DIO_info->pins);
    111c:	94 b3       	in	r25, 0x14	; 20
    111e:	81 81       	ldd	r24, Z+1	; 0x01
    1120:	89 2b       	or	r24, r25
    1122:	84 bb       	out	0x14, r24	; 20
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    1124:	80 e0       	ldi	r24, 0x00	; 0
    1126:	08 95       	ret
               EROR=E_NOK;
               break;
         case GPIOC:
               if(DIO_info->dir==OUTPUT)
               PORTC_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
    1128:	81 11       	cpse	r24, r1
    112a:	21 c0       	rjmp	.+66     	; 0x116e <DIO_init+0xba>
               PORTC_DIR&=~(DIO_info->pins);
    112c:	94 b3       	in	r25, 0x14	; 20
    112e:	81 81       	ldd	r24, Z+1	; 0x01
    1130:	80 95       	com	r24
    1132:	89 23       	and	r24, r25
    1134:	84 bb       	out	0x14, r24	; 20
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    1136:	80 e0       	ldi	r24, 0x00	; 0
    1138:	08 95       	ret
               PORTC_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
               break;
         case GPIOD:
               if(DIO_info->dir==OUTPUT)
    113a:	82 81       	ldd	r24, Z+2	; 0x02
    113c:	8f 3f       	cpi	r24, 0xFF	; 255
    113e:	31 f4       	brne	.+12     	; 0x114c <DIO_init+0x98>
               PORTD_DIR|=(DIO_info->pins);
    1140:	91 b3       	in	r25, 0x11	; 17
    1142:	81 81       	ldd	r24, Z+1	; 0x01
    1144:	89 2b       	or	r24, r25
    1146:	81 bb       	out	0x11, r24	; 17
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	08 95       	ret
               EROR=E_NOK;
               break;
         case GPIOD:
               if(DIO_info->dir==OUTPUT)
               PORTD_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
    114c:	81 11       	cpse	r24, r1
    114e:	11 c0       	rjmp	.+34     	; 0x1172 <DIO_init+0xbe>
               PORTD_DIR&=~(DIO_info->pins);
    1150:	91 b3       	in	r25, 0x11	; 17
    1152:	81 81       	ldd	r24, Z+1	; 0x01
    1154:	80 95       	com	r24
    1156:	89 23       	and	r24, r25
    1158:	81 bb       	out	0x11, r24	; 17
/*Return:Error status*/
/*Description: This function can set the direction of a full port, a nibble or even one pin.*/
/******************************************************************************************/
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{/*ERROR RET VARIBALE*/ 
   ERROR_STATUS  EROR=E_OK;
    115a:	80 e0       	ldi	r24, 0x00	; 0
    115c:	08 95       	ret
         
      }   
   }
   else
   {
      EROR=E_NOK;
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	08 95       	ret
               PORTD_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
               break;
         default:
               EROR=E_NOK;
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	08 95       	ret
               if(DIO_info->dir==OUTPUT)
               PORTA_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
               PORTA_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
    1166:	81 e0       	ldi	r24, 0x01	; 1
    1168:	08 95       	ret
               if(DIO_info->dir==OUTPUT)
               PORTB_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
               PORTB_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	08 95       	ret
               if(DIO_info->dir==OUTPUT)
               PORTC_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
               PORTC_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	08 95       	ret
               if(DIO_info->dir==OUTPUT)
               PORTD_DIR|=(DIO_info->pins);
               else if(DIO_info->dir==INPUT)
               PORTD_DIR&=~(DIO_info->pins);
               else
               EROR=E_NOK;
    1172:	81 e0       	ldi	r24, 0x01	; 1
      EROR=E_NOK;
   }
   
   
   return EROR;
}
    1174:	08 95       	ret

00001176 <DIO_Write>:
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
  /*choose any PORT*/  
   switch (GPIO)
    1176:	81 30       	cpi	r24, 0x01	; 1
    1178:	a9 f0       	breq	.+42     	; 0x11a4 <DIO_Write+0x2e>
    117a:	28 f0       	brcs	.+10     	; 0x1186 <DIO_Write+0x10>
    117c:	82 30       	cpi	r24, 0x02	; 2
    117e:	09 f1       	breq	.+66     	; 0x11c2 <DIO_Write+0x4c>
    1180:	83 30       	cpi	r24, 0x03	; 3
    1182:	71 f1       	breq	.+92     	; 0x11e0 <DIO_Write+0x6a>
    1184:	3c c0       	rjmp	.+120    	; 0x11fe <DIO_Write+0x88>
   {
      case GPIOA:
            if(value==HIGH)
    1186:	4f 3f       	cpi	r20, 0xFF	; 255
    1188:	29 f4       	brne	.+10     	; 0x1194 <DIO_Write+0x1e>
            PORTA_DATA|=pins;
    118a:	8b b3       	in	r24, 0x1b	; 27
    118c:	68 2b       	or	r22, r24
    118e:	6b bb       	out	0x1b, r22	; 27
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	08 95       	ret
   switch (GPIO)
   {
      case GPIOA:
            if(value==HIGH)
            PORTA_DATA|=pins;
            else if(value==LOW)
    1194:	41 11       	cpse	r20, r1
    1196:	35 c0       	rjmp	.+106    	; 0x1202 <DIO_Write+0x8c>
            PORTA_DATA&=~(pins);
    1198:	8b b3       	in	r24, 0x1b	; 27
    119a:	60 95       	com	r22
    119c:	68 23       	and	r22, r24
    119e:	6b bb       	out	0x1b, r22	; 27
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11a0:	80 e0       	ldi	r24, 0x00	; 0
    11a2:	08 95       	ret
            PORTA_DATA&=~(pins);
            else
            EROR=E_NOK;
            break;
      case GPIOB:
            if(value==HIGH)
    11a4:	4f 3f       	cpi	r20, 0xFF	; 255
    11a6:	29 f4       	brne	.+10     	; 0x11b2 <DIO_Write+0x3c>
            PORTB_DATA|=pins;
    11a8:	88 b3       	in	r24, 0x18	; 24
    11aa:	68 2b       	or	r22, r24
    11ac:	68 bb       	out	0x18, r22	; 24
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11ae:	80 e0       	ldi	r24, 0x00	; 0
    11b0:	08 95       	ret
            EROR=E_NOK;
            break;
      case GPIOB:
            if(value==HIGH)
            PORTB_DATA|=pins;
            else if(value==LOW)
    11b2:	41 11       	cpse	r20, r1
    11b4:	28 c0       	rjmp	.+80     	; 0x1206 <DIO_Write+0x90>
            PORTB_DATA&=~(pins);
    11b6:	88 b3       	in	r24, 0x18	; 24
    11b8:	60 95       	com	r22
    11ba:	68 23       	and	r22, r24
    11bc:	68 bb       	out	0x18, r22	; 24
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11be:	80 e0       	ldi	r24, 0x00	; 0
    11c0:	08 95       	ret
            PORTB_DATA&=~(pins);
            else
            EROR=E_NOK;
            break;
      case GPIOC:
            if(value==HIGH)
    11c2:	4f 3f       	cpi	r20, 0xFF	; 255
    11c4:	29 f4       	brne	.+10     	; 0x11d0 <DIO_Write+0x5a>
            PORTC_DATA|=pins;
    11c6:	85 b3       	in	r24, 0x15	; 21
    11c8:	68 2b       	or	r22, r24
    11ca:	65 bb       	out	0x15, r22	; 21
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11cc:	80 e0       	ldi	r24, 0x00	; 0
    11ce:	08 95       	ret
            EROR=E_NOK;
            break;
      case GPIOC:
            if(value==HIGH)
            PORTC_DATA|=pins;
            else if(value==LOW)
    11d0:	41 11       	cpse	r20, r1
    11d2:	1b c0       	rjmp	.+54     	; 0x120a <DIO_Write+0x94>
            PORTC_DATA&=~(pins);
    11d4:	85 b3       	in	r24, 0x15	; 21
    11d6:	60 95       	com	r22
    11d8:	68 23       	and	r22, r24
    11da:	65 bb       	out	0x15, r22	; 21
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	08 95       	ret
            PORTC_DATA&=~(pins);
            else
            EROR=E_NOK;
            break;
      case GPIOD:
            if(value==HIGH)
    11e0:	4f 3f       	cpi	r20, 0xFF	; 255
    11e2:	29 f4       	brne	.+10     	; 0x11ee <DIO_Write+0x78>
            PORTD_DATA|=pins;
    11e4:	82 b3       	in	r24, 0x12	; 18
    11e6:	68 2b       	or	r22, r24
    11e8:	62 bb       	out	0x12, r22	; 18
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	08 95       	ret
            EROR=E_NOK;
            break;
      case GPIOD:
            if(value==HIGH)
            PORTD_DATA|=pins;
            else if(value==LOW)
    11ee:	41 11       	cpse	r20, r1
    11f0:	0e c0       	rjmp	.+28     	; 0x120e <DIO_Write+0x98>
            PORTD_DATA&=~(pins);
    11f2:	82 b3       	in	r24, 0x12	; 18
    11f4:	60 95       	com	r22
    11f6:	68 23       	and	r22, r24
    11f8:	62 bb       	out	0x12, r22	; 18
* 			  or even one pin.
*/
ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{ 
/*ERROR RET VARIBALE*/  
   ERROR_STATUS EROR=E_OK;
    11fa:	80 e0       	ldi	r24, 0x00	; 0
    11fc:	08 95       	ret
            else
            EROR=E_NOK;
            break;
     /*if the channel is wrong */          
      default:
            EROR=E_NOK;
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	08 95       	ret
            if(value==HIGH)
            PORTA_DATA|=pins;
            else if(value==LOW)
            PORTA_DATA&=~(pins);
            else
            EROR=E_NOK;
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	08 95       	ret
            if(value==HIGH)
            PORTB_DATA|=pins;
            else if(value==LOW)
            PORTB_DATA&=~(pins);
            else
            EROR=E_NOK;
    1206:	81 e0       	ldi	r24, 0x01	; 1
    1208:	08 95       	ret
            if(value==HIGH)
            PORTC_DATA|=pins;
            else if(value==LOW)
            PORTC_DATA&=~(pins);
            else
            EROR=E_NOK;
    120a:	81 e0       	ldi	r24, 0x01	; 1
    120c:	08 95       	ret
            if(value==HIGH)
            PORTD_DATA|=pins;
            else if(value==LOW)
            PORTD_DATA&=~(pins);
            else
            EROR=E_NOK;
    120e:	81 e0       	ldi	r24, 0x01	; 1
            break;
   }


   return EROR;
}
    1210:	08 95       	ret

00001212 <DIO_Read>:

ERROR_STATUS DIO_Read (uint8_t GPIO,uint8_t pins, uint8_t *data)
{  
	ERROR_STATUS aenum_status =   E_OK;
	
		switch(GPIO){
    1212:	81 30       	cpi	r24, 0x01	; 1
    1214:	81 f0       	breq	.+32     	; 0x1236 <DIO_Read+0x24>
    1216:	28 f0       	brcs	.+10     	; 0x1222 <DIO_Read+0x10>
    1218:	82 30       	cpi	r24, 0x02	; 2
    121a:	b9 f0       	breq	.+46     	; 0x124a <DIO_Read+0x38>
    121c:	83 30       	cpi	r24, 0x03	; 3
    121e:	f9 f0       	breq	.+62     	; 0x125e <DIO_Read+0x4c>
    1220:	27 c0       	rjmp	.+78     	; 0x1270 <DIO_Read+0x5e>
			case GPIOA:
			*data = ((PORTA_PIN>>pins)*0x01);
    1222:	89 b3       	in	r24, 0x19	; 25
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	02 c0       	rjmp	.+4      	; 0x122c <DIO_Read+0x1a>
    1228:	95 95       	asr	r25
    122a:	87 95       	ror	r24
    122c:	6a 95       	dec	r22
    122e:	e2 f7       	brpl	.-8      	; 0x1228 <DIO_Read+0x16>
    1230:	fa 01       	movw	r30, r20
    1232:	80 83       	st	Z, r24
			break;
    1234:	1d c0       	rjmp	.+58     	; 0x1270 <DIO_Read+0x5e>
			case GPIOB:
			*data = ((PORTB_PIN>>pins)*0x01);
    1236:	86 b3       	in	r24, 0x16	; 22
    1238:	90 e0       	ldi	r25, 0x00	; 0
    123a:	02 c0       	rjmp	.+4      	; 0x1240 <DIO_Read+0x2e>
    123c:	95 95       	asr	r25
    123e:	87 95       	ror	r24
    1240:	6a 95       	dec	r22
    1242:	e2 f7       	brpl	.-8      	; 0x123c <DIO_Read+0x2a>
    1244:	fa 01       	movw	r30, r20
    1246:	80 83       	st	Z, r24
			break;
    1248:	13 c0       	rjmp	.+38     	; 0x1270 <DIO_Read+0x5e>
			case GPIOC:
			*data = ((PORTC_PIN>>pins)*0x01);
    124a:	83 b3       	in	r24, 0x13	; 19
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	02 c0       	rjmp	.+4      	; 0x1254 <DIO_Read+0x42>
    1250:	95 95       	asr	r25
    1252:	87 95       	ror	r24
    1254:	6a 95       	dec	r22
    1256:	e2 f7       	brpl	.-8      	; 0x1250 <DIO_Read+0x3e>
    1258:	fa 01       	movw	r30, r20
    125a:	80 83       	st	Z, r24
			break;
    125c:	09 c0       	rjmp	.+18     	; 0x1270 <DIO_Read+0x5e>
			case GPIOD:
			*data = ((PORTD_PIN>>pins)*0x01);
    125e:	80 b3       	in	r24, 0x10	; 16
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	02 c0       	rjmp	.+4      	; 0x1268 <DIO_Read+0x56>
    1264:	95 95       	asr	r25
    1266:	87 95       	ror	r24
    1268:	6a 95       	dec	r22
    126a:	e2 f7       	brpl	.-8      	; 0x1264 <DIO_Read+0x52>
    126c:	fa 01       	movw	r30, r20
    126e:	80 83       	st	Z, r24
			default:
			break;
		}
	
	return aenum_status;
}
    1270:	80 e0       	ldi	r24, 0x00	; 0
    1272:	08 95       	ret

00001274 <UART_init>:
	{
		i++;
		Str[i] = UART_recieveByte();
	}
	Str[i] = '\0';
}
    1274:	fc 01       	movw	r30, r24
    1276:	78 94       	sei
    1278:	94 85       	ldd	r25, Z+12	; 0x0c
    127a:	85 85       	ldd	r24, Z+13	; 0x0d
    127c:	89 2b       	or	r24, r25
    127e:	8b b9       	out	0x0b, r24	; 11
    1280:	95 81       	ldd	r25, Z+5	; 0x05
    1282:	86 81       	ldd	r24, Z+6	; 0x06
    1284:	89 2b       	or	r24, r25
    1286:	97 81       	ldd	r25, Z+7	; 0x07
    1288:	89 2b       	or	r24, r25
    128a:	90 85       	ldd	r25, Z+8	; 0x08
    128c:	89 2b       	or	r24, r25
    128e:	91 85       	ldd	r25, Z+9	; 0x09
    1290:	89 2b       	or	r24, r25
    1292:	92 85       	ldd	r25, Z+10	; 0x0a
    1294:	89 2b       	or	r24, r25
    1296:	93 85       	ldd	r25, Z+11	; 0x0b
    1298:	89 2b       	or	r24, r25
    129a:	8a b9       	out	0x0a, r24	; 10
    129c:	90 81       	ld	r25, Z
    129e:	81 81       	ldd	r24, Z+1	; 0x01
    12a0:	89 2b       	or	r24, r25
    12a2:	80 68       	ori	r24, 0x80	; 128
    12a4:	92 81       	ldd	r25, Z+2	; 0x02
    12a6:	89 2b       	or	r24, r25
    12a8:	93 81       	ldd	r25, Z+3	; 0x03
    12aa:	89 2b       	or	r24, r25
    12ac:	94 81       	ldd	r25, Z+4	; 0x04
    12ae:	89 2b       	or	r24, r25
    12b0:	80 bd       	out	0x20, r24	; 32
    12b2:	87 85       	ldd	r24, Z+15	; 0x0f
    12b4:	80 bd       	out	0x20, r24	; 32
    12b6:	86 85       	ldd	r24, Z+14	; 0x0e
    12b8:	89 b9       	out	0x09, r24	; 9
    12ba:	08 95       	ret

000012bc <UART_sendByte>:
    12bc:	5d 9b       	sbis	0x0b, 5	; 11
    12be:	fe cf       	rjmp	.-4      	; 0x12bc <UART_sendByte>
    12c0:	8c b9       	out	0x0c, r24	; 12
    12c2:	08 95       	ret

000012c4 <__vector_15>:
/****************************************************************************************/

/***************************UART interrupt functions*************************************/
ISR(USART_TXC_vect)
{
    12c4:	1f 92       	push	r1
    12c6:	0f 92       	push	r0
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	0f 92       	push	r0
    12cc:	11 24       	eor	r1, r1
	g8_UART_TX_FLAG = FLAG_LOW;
    12ce:	10 92 ca 06 	sts	0x06CA, r1	; 0x8006ca <g8_UART_TX_FLAG>
}
    12d2:	0f 90       	pop	r0
    12d4:	0f be       	out	0x3f, r0	; 63
    12d6:	0f 90       	pop	r0
    12d8:	1f 90       	pop	r1
    12da:	18 95       	reti

000012dc <__vector_13>:

ISR(USART_RXC_vect)
{
    12dc:	1f 92       	push	r1
    12de:	0f 92       	push	r0
    12e0:	0f b6       	in	r0, 0x3f	; 63
    12e2:	0f 92       	push	r0
    12e4:	11 24       	eor	r1, r1
    12e6:	2f 93       	push	r18
    12e8:	3f 93       	push	r19
    12ea:	4f 93       	push	r20
    12ec:	5f 93       	push	r21
    12ee:	6f 93       	push	r22
    12f0:	7f 93       	push	r23
    12f2:	8f 93       	push	r24
    12f4:	9f 93       	push	r25
    12f6:	af 93       	push	r26
    12f8:	bf 93       	push	r27
    12fa:	ef 93       	push	r30
    12fc:	ff 93       	push	r31
	g8_udr_data[gu8_counterrec] = UDR;
    12fe:	e0 91 c8 06 	lds	r30, 0x06C8	; 0x8006c8 <gu8_counterrec>
    1302:	f0 e0       	ldi	r31, 0x00	; 0
    1304:	8c b1       	in	r24, 0x0c	; 12
    1306:	e0 52       	subi	r30, 0x20	; 32
    1308:	f9 4f       	sbci	r31, 0xF9	; 249
    130a:	80 83       	st	Z, r24
	gu8_counterrec++;
    130c:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <gu8_counterrec>
    1310:	8f 5f       	subi	r24, 0xFF	; 255
    1312:	80 93 c8 06 	sts	0x06C8, r24	; 0x8006c8 <gu8_counterrec>
	g8_UART_RX_FLAG = FLAG_HIGH;
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <g8_UART_RX_FLAG>
	if(gu8_counterrec==1)
    131c:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <gu8_counterrec>
    1320:	81 30       	cpi	r24, 0x01	; 1
    1322:	11 f4       	brne	.+4      	; 0x1328 <__vector_13+0x4c>
	{
		LCD_goToRowColumn(1,0);
    1324:	60 e0       	ldi	r22, 0x00	; 0
    1326:	cc dd       	rcall	.-1128   	; 0xec0 <LCD_goToRowColumn>
	}
	LCD_displayCharacter(gu8_counterrec+48);
    1328:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <gu8_counterrec>
    132c:	80 5d       	subi	r24, 0xD0	; 208
    132e:	81 dd       	rcall	.-1278   	; 0xe32 <LCD_displayCharacter>
	if(gu8_counterrec==5)
    1330:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <gu8_counterrec>
    1334:	85 30       	cpi	r24, 0x05	; 5
    1336:	19 f4       	brne	.+6      	; 0x133e <__vector_13+0x62>
	{
		
		LCD_goToRowColumn(0,0);
    1338:	60 e0       	ldi	r22, 0x00	; 0
    133a:	80 e0       	ldi	r24, 0x00	; 0
    133c:	c1 dd       	rcall	.-1150   	; 0xec0 <LCD_goToRowColumn>
	}
		
	
}
    133e:	ff 91       	pop	r31
    1340:	ef 91       	pop	r30
    1342:	bf 91       	pop	r27
    1344:	af 91       	pop	r26
    1346:	9f 91       	pop	r25
    1348:	8f 91       	pop	r24
    134a:	7f 91       	pop	r23
    134c:	6f 91       	pop	r22
    134e:	5f 91       	pop	r21
    1350:	4f 91       	pop	r20
    1352:	3f 91       	pop	r19
    1354:	2f 91       	pop	r18
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	0f 90       	pop	r0
    135c:	1f 90       	pop	r1
    135e:	18 95       	reti

00001360 <_exit>:
    1360:	f8 94       	cli

00001362 <__stop_program>:
    1362:	ff cf       	rjmp	.-2      	; 0x1362 <__stop_program>
