
story1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000df8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00000df8  00000e8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000646  00800074  00800074  00000ea0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ea0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000ed0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002b8  00000000  00000000  00000f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002f9f  00000000  00000000  000011c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f3e  00000000  00000000  00004163  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002a5e  00000000  00000000  000050a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000768  00000000  00000000  00007b00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000c7d6  00000000  00000000  00008268  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000029e8  00000000  00000000  00014a3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000280  00000000  00000000  00017426  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000037d3  00000000  00000000  000176a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
   2:	00 00       	nop
   4:	42 c0       	rjmp	.+132    	; 0x8a <__bad_interrupt>
   6:	00 00       	nop
   8:	40 c0       	rjmp	.+128    	; 0x8a <__bad_interrupt>
   a:	00 00       	nop
   c:	3e c0       	rjmp	.+124    	; 0x8a <__bad_interrupt>
   e:	00 00       	nop
  10:	3c c0       	rjmp	.+120    	; 0x8a <__bad_interrupt>
  12:	00 00       	nop
  14:	3a c0       	rjmp	.+116    	; 0x8a <__bad_interrupt>
  16:	00 00       	nop
  18:	38 c0       	rjmp	.+112    	; 0x8a <__bad_interrupt>
  1a:	00 00       	nop
  1c:	04 c2       	rjmp	.+1032   	; 0x426 <__vector_7>
  1e:	00 00       	nop
  20:	34 c0       	rjmp	.+104    	; 0x8a <__bad_interrupt>
  22:	00 00       	nop
  24:	32 c0       	rjmp	.+100    	; 0x8a <__bad_interrupt>
  26:	00 00       	nop
  28:	30 c0       	rjmp	.+96     	; 0x8a <__bad_interrupt>
  2a:	00 00       	nop
  2c:	2e c0       	rjmp	.+92     	; 0x8a <__bad_interrupt>
  2e:	00 00       	nop
  30:	2c c0       	rjmp	.+88     	; 0x8a <__bad_interrupt>
  32:	00 00       	nop
  34:	2a c0       	rjmp	.+84     	; 0x8a <__bad_interrupt>
  36:	00 00       	nop
  38:	28 c0       	rjmp	.+80     	; 0x8a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	26 c0       	rjmp	.+76     	; 0x8a <__bad_interrupt>
  3e:	00 00       	nop
  40:	24 c0       	rjmp	.+72     	; 0x8a <__bad_interrupt>
  42:	00 00       	nop
  44:	22 c0       	rjmp	.+68     	; 0x8a <__bad_interrupt>
  46:	00 00       	nop
  48:	20 c0       	rjmp	.+64     	; 0x8a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	1e c0       	rjmp	.+60     	; 0x8a <__bad_interrupt>
  4e:	00 00       	nop
  50:	1c c0       	rjmp	.+56     	; 0x8a <__bad_interrupt>
	...

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 ef       	ldi	r30, 0xF8	; 248
  68:	fd e0       	ldi	r31, 0x0D	; 13
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 37       	cpi	r26, 0x74	; 116
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	a4 e7       	ldi	r26, 0x74	; 116
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	aa 3b       	cpi	r26, 0xBA	; 186
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	34 d6       	rcall	.+3176   	; 0xcf0 <main>
  88:	b5 c6       	rjmp	.+3434   	; 0xdf4 <_exit>

0000008a <__bad_interrupt>:
  8a:	ba cf       	rjmp	.-140    	; 0x0 <__vectors>

0000008c <UserStoryOneInit>:
************************************************************************************/
void UserStoryOneInit(void)
{
	TaskHandle_t xHandle = NULL;
	 /* initialize the LED */
	Led_Init(LED_0); 
  8c:	80 e0       	ldi	r24, 0x00	; 0
  8e:	be d5       	rcall	.+2940   	; 0xc0c <Led_Init>
	
		
		xHandle=xTaskGetCurrentTaskHandle();
  90:	b8 d5       	rcall	.+2928   	; 0xc02 <xTaskGetCurrentTaskHandle>
		vTaskDelete(xHandle);
  92:	83 c3       	rjmp	.+1798   	; 0x79a <vTaskDelete>
  94:	08 95       	ret

00000096 <UserStoryOne>:
  96:	cf 93       	push	r28
* Parameters (out): None
* Return value: None
* Description: this function toggles LED number zero
************************************************************************************/
void UserStoryOne(void)
{
  98:	df 93       	push	r29
  9a:	00 d0       	rcall	.+0      	; 0x9c <UserStoryOne+0x6>
  9c:	cd b7       	in	r28, 0x3d	; 61
  9e:	de b7       	in	r29, 0x3e	; 62
	TickType_t UserStoryOne_LastWakeTime;
	const TickType_t UserStoryOne_Frequency = ONE_MS;

    /* Initialize the xLastWakeTime variable with the current time */
	UserStoryOne_LastWakeTime = xTaskGetTickCount();
  a0:	f8 d3       	rcall	.+2032   	; 0x892 <xTaskGetTickCount>
  a2:	9a 83       	std	Y+2, r25	; 0x02
  a4:	89 83       	std	Y+1, r24	; 0x01
	while(TRUE)
	{
		Led_Toggle(LED_0);		 /* toggle the LED */
  a6:	80 e0       	ldi	r24, 0x00	; 0
  a8:	e3 d5       	rcall	.+3014   	; 0xc70 <Led_Toggle>
        /* Wait for the next cycle */
        vTaskDelayUntil( &UserStoryOne_LastWakeTime, UserStoryOne_Frequency);
  aa:	68 ee       	ldi	r22, 0xE8	; 232
  ac:	73 e0       	ldi	r23, 0x03	; 3
  ae:	ce 01       	movw	r24, r28
  b0:	01 96       	adiw	r24, 0x01	; 1
  b2:	07 d5       	rcall	.+2574   	; 0xac2 <vTaskDelayUntil>
  b4:	f8 cf       	rjmp	.-16     	; 0xa6 <UserStoryOne+0x10>

000000b6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
  bc:	e4 d3       	rcall	.+1992   	; 0x886 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  be:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <__data_end>
  c2:	90 91 75 00 	lds	r25, 0x0075	; 0x800075 <__data_end+0x1>
  c6:	89 2b       	or	r24, r25
  c8:	31 f4       	brne	.+12     	; 0xd6 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  ca:	89 e7       	ldi	r24, 0x79	; 121
  cc:	90 e0       	ldi	r25, 0x00	; 0
  ce:	90 93 75 00 	sts	0x0075, r25	; 0x800075 <__data_end+0x1>
  d2:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  d6:	20 91 76 00 	lds	r18, 0x0076	; 0x800076 <xNextFreeByte>
  da:	30 91 77 00 	lds	r19, 0x0077	; 0x800077 <xNextFreeByte+0x1>
  de:	c9 01       	movw	r24, r18
  e0:	8c 0f       	add	r24, r28
  e2:	9d 1f       	adc	r25, r29
  e4:	8b 3d       	cpi	r24, 0xDB	; 219
  e6:	45 e0       	ldi	r20, 0x05	; 5
  e8:	94 07       	cpc	r25, r20
  ea:	70 f4       	brcc	.+28     	; 0x108 <pvPortMalloc+0x52>
  ec:	28 17       	cp	r18, r24
  ee:	39 07       	cpc	r19, r25
  f0:	70 f4       	brcc	.+28     	; 0x10e <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  f2:	c0 91 74 00 	lds	r28, 0x0074	; 0x800074 <__data_end>
  f6:	d0 91 75 00 	lds	r29, 0x0075	; 0x800075 <__data_end+0x1>
  fa:	c2 0f       	add	r28, r18
  fc:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
  fe:	90 93 77 00 	sts	0x0077, r25	; 0x800077 <xNextFreeByte+0x1>
 102:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <xNextFreeByte>
 106:	05 c0       	rjmp	.+10     	; 0x112 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 108:	c0 e0       	ldi	r28, 0x00	; 0
 10a:	d0 e0       	ldi	r29, 0x00	; 0
 10c:	02 c0       	rjmp	.+4      	; 0x112 <pvPortMalloc+0x5c>
 10e:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 110:	d0 e0       	ldi	r29, 0x00	; 0
 112:	65 d4       	rcall	.+2250   	; 0x9de <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 114:	ce 01       	movw	r24, r28
 116:	df 91       	pop	r29
 118:	cf 91       	pop	r28
 11a:	08 95       	ret

0000011c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 11c:	08 95       	ret

0000011e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 11e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 120:	03 96       	adiw	r24, 0x03	; 3
 122:	92 83       	std	Z+2, r25	; 0x02
 124:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 126:	2f ef       	ldi	r18, 0xFF	; 255
 128:	3f ef       	ldi	r19, 0xFF	; 255
 12a:	34 83       	std	Z+4, r19	; 0x04
 12c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 12e:	96 83       	std	Z+6, r25	; 0x06
 130:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 132:	90 87       	std	Z+8, r25	; 0x08
 134:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 136:	10 82       	st	Z, r1
 138:	08 95       	ret

0000013a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 13a:	fc 01       	movw	r30, r24
 13c:	11 86       	std	Z+9, r1	; 0x09
 13e:	10 86       	std	Z+8, r1	; 0x08
 140:	08 95       	ret

00000142 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 142:	cf 93       	push	r28
 144:	df 93       	push	r29
 146:	9c 01       	movw	r18, r24
 148:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 14a:	dc 01       	movw	r26, r24
 14c:	11 96       	adiw	r26, 0x01	; 1
 14e:	cd 91       	ld	r28, X+
 150:	dc 91       	ld	r29, X
 152:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 154:	d3 83       	std	Z+3, r29	; 0x03
 156:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 158:	8c 81       	ldd	r24, Y+4	; 0x04
 15a:	9d 81       	ldd	r25, Y+5	; 0x05
 15c:	95 83       	std	Z+5, r25	; 0x05
 15e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 160:	8c 81       	ldd	r24, Y+4	; 0x04
 162:	9d 81       	ldd	r25, Y+5	; 0x05
 164:	dc 01       	movw	r26, r24
 166:	13 96       	adiw	r26, 0x03	; 3
 168:	7c 93       	st	X, r23
 16a:	6e 93       	st	-X, r22
 16c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 16e:	7d 83       	std	Y+5, r23	; 0x05
 170:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 172:	31 87       	std	Z+9, r19	; 0x09
 174:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 176:	f9 01       	movw	r30, r18
 178:	80 81       	ld	r24, Z
 17a:	8f 5f       	subi	r24, 0xFF	; 255
 17c:	80 83       	st	Z, r24
}
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	08 95       	ret

00000184 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 184:	cf 93       	push	r28
 186:	df 93       	push	r29
 188:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 18a:	48 81       	ld	r20, Y
 18c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 18e:	4f 3f       	cpi	r20, 0xFF	; 255
 190:	2f ef       	ldi	r18, 0xFF	; 255
 192:	52 07       	cpc	r21, r18
 194:	21 f4       	brne	.+8      	; 0x19e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 196:	fc 01       	movw	r30, r24
 198:	a7 81       	ldd	r26, Z+7	; 0x07
 19a:	b0 85       	ldd	r27, Z+8	; 0x08
 19c:	0d c0       	rjmp	.+26     	; 0x1b8 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 19e:	dc 01       	movw	r26, r24
 1a0:	13 96       	adiw	r26, 0x03	; 3
 1a2:	01 c0       	rjmp	.+2      	; 0x1a6 <vListInsert+0x22>
 1a4:	df 01       	movw	r26, r30
 1a6:	12 96       	adiw	r26, 0x02	; 2
 1a8:	ed 91       	ld	r30, X+
 1aa:	fc 91       	ld	r31, X
 1ac:	13 97       	sbiw	r26, 0x03	; 3
 1ae:	20 81       	ld	r18, Z
 1b0:	31 81       	ldd	r19, Z+1	; 0x01
 1b2:	42 17       	cp	r20, r18
 1b4:	53 07       	cpc	r21, r19
 1b6:	b0 f7       	brcc	.-20     	; 0x1a4 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1b8:	12 96       	adiw	r26, 0x02	; 2
 1ba:	ed 91       	ld	r30, X+
 1bc:	fc 91       	ld	r31, X
 1be:	13 97       	sbiw	r26, 0x03	; 3
 1c0:	fb 83       	std	Y+3, r31	; 0x03
 1c2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1c4:	d5 83       	std	Z+5, r29	; 0x05
 1c6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1c8:	bd 83       	std	Y+5, r27	; 0x05
 1ca:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1cc:	13 96       	adiw	r26, 0x03	; 3
 1ce:	dc 93       	st	X, r29
 1d0:	ce 93       	st	-X, r28
 1d2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 1d4:	99 87       	std	Y+9, r25	; 0x09
 1d6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1d8:	fc 01       	movw	r30, r24
 1da:	20 81       	ld	r18, Z
 1dc:	2f 5f       	subi	r18, 0xFF	; 255
 1de:	20 83       	st	Z, r18
}
 1e0:	df 91       	pop	r29
 1e2:	cf 91       	pop	r28
 1e4:	08 95       	ret

000001e6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1e6:	cf 93       	push	r28
 1e8:	df 93       	push	r29
 1ea:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 1ec:	a0 85       	ldd	r26, Z+8	; 0x08
 1ee:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1f0:	c2 81       	ldd	r28, Z+2	; 0x02
 1f2:	d3 81       	ldd	r29, Z+3	; 0x03
 1f4:	84 81       	ldd	r24, Z+4	; 0x04
 1f6:	95 81       	ldd	r25, Z+5	; 0x05
 1f8:	9d 83       	std	Y+5, r25	; 0x05
 1fa:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1fc:	c4 81       	ldd	r28, Z+4	; 0x04
 1fe:	d5 81       	ldd	r29, Z+5	; 0x05
 200:	82 81       	ldd	r24, Z+2	; 0x02
 202:	93 81       	ldd	r25, Z+3	; 0x03
 204:	9b 83       	std	Y+3, r25	; 0x03
 206:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 208:	11 96       	adiw	r26, 0x01	; 1
 20a:	8d 91       	ld	r24, X+
 20c:	9c 91       	ld	r25, X
 20e:	12 97       	sbiw	r26, 0x02	; 2
 210:	e8 17       	cp	r30, r24
 212:	f9 07       	cpc	r31, r25
 214:	31 f4       	brne	.+12     	; 0x222 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 216:	84 81       	ldd	r24, Z+4	; 0x04
 218:	95 81       	ldd	r25, Z+5	; 0x05
 21a:	12 96       	adiw	r26, 0x02	; 2
 21c:	9c 93       	st	X, r25
 21e:	8e 93       	st	-X, r24
 220:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 222:	11 86       	std	Z+9, r1	; 0x09
 224:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 226:	8c 91       	ld	r24, X
 228:	81 50       	subi	r24, 0x01	; 1
 22a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 22c:	8c 91       	ld	r24, X
}
 22e:	df 91       	pop	r29
 230:	cf 91       	pop	r28
 232:	08 95       	ret

00000234 <pxPortInitialiseStack>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
 234:	31 e1       	ldi	r19, 0x11	; 17
 236:	fc 01       	movw	r30, r24
 238:	30 83       	st	Z, r19
 23a:	31 97       	sbiw	r30, 0x01	; 1
 23c:	22 e2       	ldi	r18, 0x22	; 34
 23e:	20 83       	st	Z, r18
 240:	31 97       	sbiw	r30, 0x01	; 1
 242:	a3 e3       	ldi	r26, 0x33	; 51
 244:	a0 83       	st	Z, r26
 246:	31 97       	sbiw	r30, 0x01	; 1
 248:	60 83       	st	Z, r22
 24a:	31 97       	sbiw	r30, 0x01	; 1
 24c:	70 83       	st	Z, r23
 24e:	31 97       	sbiw	r30, 0x01	; 1
 250:	10 82       	st	Z, r1
 252:	31 97       	sbiw	r30, 0x01	; 1
 254:	60 e8       	ldi	r22, 0x80	; 128
 256:	60 83       	st	Z, r22
 258:	31 97       	sbiw	r30, 0x01	; 1
 25a:	10 82       	st	Z, r1
 25c:	31 97       	sbiw	r30, 0x01	; 1
 25e:	62 e0       	ldi	r22, 0x02	; 2
 260:	60 83       	st	Z, r22
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	63 e0       	ldi	r22, 0x03	; 3
 266:	60 83       	st	Z, r22
 268:	31 97       	sbiw	r30, 0x01	; 1
 26a:	64 e0       	ldi	r22, 0x04	; 4
 26c:	60 83       	st	Z, r22
 26e:	31 97       	sbiw	r30, 0x01	; 1
 270:	65 e0       	ldi	r22, 0x05	; 5
 272:	60 83       	st	Z, r22
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	66 e0       	ldi	r22, 0x06	; 6
 278:	60 83       	st	Z, r22
 27a:	31 97       	sbiw	r30, 0x01	; 1
 27c:	67 e0       	ldi	r22, 0x07	; 7
 27e:	60 83       	st	Z, r22
 280:	31 97       	sbiw	r30, 0x01	; 1
 282:	68 e0       	ldi	r22, 0x08	; 8
 284:	60 83       	st	Z, r22
 286:	31 97       	sbiw	r30, 0x01	; 1
 288:	69 e0       	ldi	r22, 0x09	; 9
 28a:	60 83       	st	Z, r22
 28c:	31 97       	sbiw	r30, 0x01	; 1
 28e:	60 e1       	ldi	r22, 0x10	; 16
 290:	60 83       	st	Z, r22
 292:	31 97       	sbiw	r30, 0x01	; 1
 294:	30 83       	st	Z, r19
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	32 e1       	ldi	r19, 0x12	; 18
 29a:	30 83       	st	Z, r19
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	33 e1       	ldi	r19, 0x13	; 19
 2a0:	30 83       	st	Z, r19
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	34 e1       	ldi	r19, 0x14	; 20
 2a6:	30 83       	st	Z, r19
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	35 e1       	ldi	r19, 0x15	; 21
 2ac:	30 83       	st	Z, r19
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	36 e1       	ldi	r19, 0x16	; 22
 2b2:	30 83       	st	Z, r19
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	37 e1       	ldi	r19, 0x17	; 23
 2b8:	30 83       	st	Z, r19
 2ba:	31 97       	sbiw	r30, 0x01	; 1
 2bc:	38 e1       	ldi	r19, 0x18	; 24
 2be:	30 83       	st	Z, r19
 2c0:	31 97       	sbiw	r30, 0x01	; 1
 2c2:	39 e1       	ldi	r19, 0x19	; 25
 2c4:	30 83       	st	Z, r19
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	30 e2       	ldi	r19, 0x20	; 32
 2ca:	30 83       	st	Z, r19
 2cc:	31 97       	sbiw	r30, 0x01	; 1
 2ce:	31 e2       	ldi	r19, 0x21	; 33
 2d0:	30 83       	st	Z, r19
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	20 83       	st	Z, r18
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	23 e2       	ldi	r18, 0x23	; 35
 2da:	20 83       	st	Z, r18
 2dc:	31 97       	sbiw	r30, 0x01	; 1
 2de:	40 83       	st	Z, r20
 2e0:	31 97       	sbiw	r30, 0x01	; 1
 2e2:	50 83       	st	Z, r21
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	26 e2       	ldi	r18, 0x26	; 38
 2e8:	20 83       	st	Z, r18
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	27 e2       	ldi	r18, 0x27	; 39
 2ee:	20 83       	st	Z, r18
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	28 e2       	ldi	r18, 0x28	; 40
 2f4:	20 83       	st	Z, r18
 2f6:	31 97       	sbiw	r30, 0x01	; 1
 2f8:	29 e2       	ldi	r18, 0x29	; 41
 2fa:	20 83       	st	Z, r18
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	20 e3       	ldi	r18, 0x30	; 48
 300:	20 83       	st	Z, r18
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	21 e3       	ldi	r18, 0x31	; 49
 306:	20 83       	st	Z, r18
 308:	86 97       	sbiw	r24, 0x26	; 38
 30a:	08 95       	ret

0000030c <xPortStartScheduler>:
 30c:	1b bc       	out	0x2b, r1	; 43
 30e:	89 ef       	ldi	r24, 0xF9	; 249
 310:	8a bd       	out	0x2a, r24	; 42
 312:	8b e0       	ldi	r24, 0x0B	; 11
 314:	8e bd       	out	0x2e, r24	; 46
 316:	89 b7       	in	r24, 0x39	; 57
 318:	80 61       	ori	r24, 0x10	; 16
 31a:	89 bf       	out	0x39, r24	; 57
 31c:	a0 91 b8 06 	lds	r26, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 320:	b0 91 b9 06 	lds	r27, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 324:	cd 91       	ld	r28, X+
 326:	cd bf       	out	0x3d, r28	; 61
 328:	dd 91       	ld	r29, X+
 32a:	de bf       	out	0x3e, r29	; 62
 32c:	ff 91       	pop	r31
 32e:	ef 91       	pop	r30
 330:	df 91       	pop	r29
 332:	cf 91       	pop	r28
 334:	bf 91       	pop	r27
 336:	af 91       	pop	r26
 338:	9f 91       	pop	r25
 33a:	8f 91       	pop	r24
 33c:	7f 91       	pop	r23
 33e:	6f 91       	pop	r22
 340:	5f 91       	pop	r21
 342:	4f 91       	pop	r20
 344:	3f 91       	pop	r19
 346:	2f 91       	pop	r18
 348:	1f 91       	pop	r17
 34a:	0f 91       	pop	r16
 34c:	ff 90       	pop	r15
 34e:	ef 90       	pop	r14
 350:	df 90       	pop	r13
 352:	cf 90       	pop	r12
 354:	bf 90       	pop	r11
 356:	af 90       	pop	r10
 358:	9f 90       	pop	r9
 35a:	8f 90       	pop	r8
 35c:	7f 90       	pop	r7
 35e:	6f 90       	pop	r6
 360:	5f 90       	pop	r5
 362:	4f 90       	pop	r4
 364:	3f 90       	pop	r3
 366:	2f 90       	pop	r2
 368:	1f 90       	pop	r1
 36a:	0f 90       	pop	r0
 36c:	0f be       	out	0x3f, r0	; 63
 36e:	0f 90       	pop	r0
 370:	08 95       	ret
 372:	81 e0       	ldi	r24, 0x01	; 1
 374:	08 95       	ret

00000376 <vPortYield>:
 376:	0f 92       	push	r0
 378:	0f b6       	in	r0, 0x3f	; 63
 37a:	f8 94       	cli
 37c:	0f 92       	push	r0
 37e:	1f 92       	push	r1
 380:	11 24       	eor	r1, r1
 382:	2f 92       	push	r2
 384:	3f 92       	push	r3
 386:	4f 92       	push	r4
 388:	5f 92       	push	r5
 38a:	6f 92       	push	r6
 38c:	7f 92       	push	r7
 38e:	8f 92       	push	r8
 390:	9f 92       	push	r9
 392:	af 92       	push	r10
 394:	bf 92       	push	r11
 396:	cf 92       	push	r12
 398:	df 92       	push	r13
 39a:	ef 92       	push	r14
 39c:	ff 92       	push	r15
 39e:	0f 93       	push	r16
 3a0:	1f 93       	push	r17
 3a2:	2f 93       	push	r18
 3a4:	3f 93       	push	r19
 3a6:	4f 93       	push	r20
 3a8:	5f 93       	push	r21
 3aa:	6f 93       	push	r22
 3ac:	7f 93       	push	r23
 3ae:	8f 93       	push	r24
 3b0:	9f 93       	push	r25
 3b2:	af 93       	push	r26
 3b4:	bf 93       	push	r27
 3b6:	cf 93       	push	r28
 3b8:	df 93       	push	r29
 3ba:	ef 93       	push	r30
 3bc:	ff 93       	push	r31
 3be:	a0 91 b8 06 	lds	r26, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 3c2:	b0 91 b9 06 	lds	r27, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 3c6:	0d b6       	in	r0, 0x3d	; 61
 3c8:	0d 92       	st	X+, r0
 3ca:	0e b6       	in	r0, 0x3e	; 62
 3cc:	0d 92       	st	X+, r0
 3ce:	b3 d3       	rcall	.+1894   	; 0xb36 <vTaskSwitchContext>
 3d0:	a0 91 b8 06 	lds	r26, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 3d4:	b0 91 b9 06 	lds	r27, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 3d8:	cd 91       	ld	r28, X+
 3da:	cd bf       	out	0x3d, r28	; 61
 3dc:	dd 91       	ld	r29, X+
 3de:	de bf       	out	0x3e, r29	; 62
 3e0:	ff 91       	pop	r31
 3e2:	ef 91       	pop	r30
 3e4:	df 91       	pop	r29
 3e6:	cf 91       	pop	r28
 3e8:	bf 91       	pop	r27
 3ea:	af 91       	pop	r26
 3ec:	9f 91       	pop	r25
 3ee:	8f 91       	pop	r24
 3f0:	7f 91       	pop	r23
 3f2:	6f 91       	pop	r22
 3f4:	5f 91       	pop	r21
 3f6:	4f 91       	pop	r20
 3f8:	3f 91       	pop	r19
 3fa:	2f 91       	pop	r18
 3fc:	1f 91       	pop	r17
 3fe:	0f 91       	pop	r16
 400:	ff 90       	pop	r15
 402:	ef 90       	pop	r14
 404:	df 90       	pop	r13
 406:	cf 90       	pop	r12
 408:	bf 90       	pop	r11
 40a:	af 90       	pop	r10
 40c:	9f 90       	pop	r9
 40e:	8f 90       	pop	r8
 410:	7f 90       	pop	r7
 412:	6f 90       	pop	r6
 414:	5f 90       	pop	r5
 416:	4f 90       	pop	r4
 418:	3f 90       	pop	r3
 41a:	2f 90       	pop	r2
 41c:	1f 90       	pop	r1
 41e:	0f 90       	pop	r0
 420:	0f be       	out	0x3f, r0	; 63
 422:	0f 90       	pop	r0
 424:	08 95       	ret

00000426 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect()  __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
 426:	1f 92       	push	r1
 428:	0f 92       	push	r0
 42a:	0f b6       	in	r0, 0x3f	; 63
 42c:	0f 92       	push	r0
 42e:	11 24       	eor	r1, r1
 430:	2f 93       	push	r18
 432:	3f 93       	push	r19
 434:	4f 93       	push	r20
 436:	5f 93       	push	r21
 438:	6f 93       	push	r22
 43a:	7f 93       	push	r23
 43c:	8f 93       	push	r24
 43e:	9f 93       	push	r25
 440:	af 93       	push	r26
 442:	bf 93       	push	r27
 444:	ef 93       	push	r30
 446:	ff 93       	push	r31
		xTaskIncrementTick();
 448:	2e d2       	rcall	.+1116   	; 0x8a6 <xTaskIncrementTick>
	}
 44a:	ff 91       	pop	r31
 44c:	ef 91       	pop	r30
 44e:	bf 91       	pop	r27
 450:	af 91       	pop	r26
 452:	9f 91       	pop	r25
 454:	8f 91       	pop	r24
 456:	7f 91       	pop	r23
 458:	6f 91       	pop	r22
 45a:	5f 91       	pop	r21
 45c:	4f 91       	pop	r20
 45e:	3f 91       	pop	r19
 460:	2f 91       	pop	r18
 462:	0f 90       	pop	r0
 464:	0f be       	out	0x3f, r0	; 63
 466:	0f 90       	pop	r0
 468:	1f 90       	pop	r1
 46a:	18 95       	reti

0000046c <prvResetNextTaskUnblockTime>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 46c:	e0 91 80 06 	lds	r30, 0x0680	; 0x800680 <pxDelayedTaskList>
 470:	f0 91 81 06 	lds	r31, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 474:	80 81       	ld	r24, Z
 476:	81 11       	cpse	r24, r1
 478:	07 c0       	rjmp	.+14     	; 0x488 <prvResetNextTaskUnblockTime+0x1c>
 47a:	8f ef       	ldi	r24, 0xFF	; 255
 47c:	9f ef       	ldi	r25, 0xFF	; 255
 47e:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 482:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 486:	08 95       	ret
 488:	e0 91 80 06 	lds	r30, 0x0680	; 0x800680 <pxDelayedTaskList>
 48c:	f0 91 81 06 	lds	r31, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 490:	05 80       	ldd	r0, Z+5	; 0x05
 492:	f6 81       	ldd	r31, Z+6	; 0x06
 494:	e0 2d       	mov	r30, r0
 496:	06 80       	ldd	r0, Z+6	; 0x06
 498:	f7 81       	ldd	r31, Z+7	; 0x07
 49a:	e0 2d       	mov	r30, r0
 49c:	82 81       	ldd	r24, Z+2	; 0x02
 49e:	93 81       	ldd	r25, Z+3	; 0x03
 4a0:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 4a4:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 4a8:	08 95       	ret

000004aa <prvIdleTask>:
 4aa:	0c e6       	ldi	r16, 0x6C	; 108
 4ac:	16 e0       	ldi	r17, 0x06	; 6
 4ae:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxDeletedTasksWaitingCleanUp>
 4b2:	88 23       	and	r24, r24
 4b4:	11 f1       	breq	.+68     	; 0x4fa <prvIdleTask+0x50>
 4b6:	0f b6       	in	r0, 0x3f	; 63
 4b8:	f8 94       	cli
 4ba:	0f 92       	push	r0
 4bc:	d8 01       	movw	r26, r16
 4be:	15 96       	adiw	r26, 0x05	; 5
 4c0:	ed 91       	ld	r30, X+
 4c2:	fc 91       	ld	r31, X
 4c4:	16 97       	sbiw	r26, 0x06	; 6
 4c6:	c6 81       	ldd	r28, Z+6	; 0x06
 4c8:	d7 81       	ldd	r29, Z+7	; 0x07
 4ca:	ce 01       	movw	r24, r28
 4cc:	02 96       	adiw	r24, 0x02	; 2
 4ce:	8b de       	rcall	.-746    	; 0x1e6 <uxListRemove>
 4d0:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 4d4:	81 50       	subi	r24, 0x01	; 1
 4d6:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxCurrentNumberOfTasks>
 4da:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxDeletedTasksWaitingCleanUp>
 4de:	81 50       	subi	r24, 0x01	; 1
 4e0:	80 93 6b 06 	sts	0x066B, r24	; 0x80066b <uxDeletedTasksWaitingCleanUp>
 4e4:	0f 90       	pop	r0
 4e6:	0f be       	out	0x3f, r0	; 63
 4e8:	8f 89       	ldd	r24, Y+23	; 0x17
 4ea:	98 8d       	ldd	r25, Y+24	; 0x18
 4ec:	17 de       	rcall	.-978    	; 0x11c <vPortFree>
 4ee:	ce 01       	movw	r24, r28
 4f0:	15 de       	rcall	.-982    	; 0x11c <vPortFree>
 4f2:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxDeletedTasksWaitingCleanUp>
 4f6:	81 11       	cpse	r24, r1
 4f8:	de cf       	rjmp	.-68     	; 0x4b6 <prvIdleTask+0xc>
 4fa:	3d df       	rcall	.-390    	; 0x376 <vPortYield>
 4fc:	d8 cf       	rjmp	.-80     	; 0x4ae <prvIdleTask+0x4>

000004fe <prvAddCurrentTaskToDelayedList>:
 4fe:	ff 92       	push	r15
 500:	0f 93       	push	r16
 502:	1f 93       	push	r17
 504:	cf 93       	push	r28
 506:	df 93       	push	r29
 508:	ec 01       	movw	r28, r24
 50a:	f6 2e       	mov	r15, r22
 50c:	00 91 5f 06 	lds	r16, 0x065F	; 0x80065f <xTickCount>
 510:	10 91 60 06 	lds	r17, 0x0660	; 0x800660 <xTickCount+0x1>
 514:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 518:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 51c:	02 96       	adiw	r24, 0x02	; 2
 51e:	63 de       	rcall	.-826    	; 0x1e6 <uxListRemove>
 520:	cf 3f       	cpi	r28, 0xFF	; 255
 522:	8f ef       	ldi	r24, 0xFF	; 255
 524:	d8 07       	cpc	r29, r24
 526:	61 f4       	brne	.+24     	; 0x540 <prvAddCurrentTaskToDelayedList+0x42>
 528:	ff 20       	and	r15, r15
 52a:	51 f0       	breq	.+20     	; 0x540 <prvAddCurrentTaskToDelayedList+0x42>
 52c:	60 91 b8 06 	lds	r22, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 530:	70 91 b9 06 	lds	r23, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 534:	6e 5f       	subi	r22, 0xFE	; 254
 536:	7f 4f       	sbci	r23, 0xFF	; 255
 538:	82 e6       	ldi	r24, 0x62	; 98
 53a:	96 e0       	ldi	r25, 0x06	; 6
 53c:	02 de       	rcall	.-1020   	; 0x142 <vListInsertEnd>
 53e:	2d c0       	rjmp	.+90     	; 0x59a <prvAddCurrentTaskToDelayedList+0x9c>
 540:	c0 0f       	add	r28, r16
 542:	d1 1f       	adc	r29, r17
 544:	e0 91 b8 06 	lds	r30, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 548:	f0 91 b9 06 	lds	r31, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 54c:	d3 83       	std	Z+3, r29	; 0x03
 54e:	c2 83       	std	Z+2, r28	; 0x02
 550:	c0 17       	cp	r28, r16
 552:	d1 07       	cpc	r29, r17
 554:	60 f4       	brcc	.+24     	; 0x56e <prvAddCurrentTaskToDelayedList+0x70>
 556:	60 91 b8 06 	lds	r22, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 55a:	70 91 b9 06 	lds	r23, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 55e:	80 91 7e 06 	lds	r24, 0x067E	; 0x80067e <pxOverflowDelayedTaskList>
 562:	90 91 7f 06 	lds	r25, 0x067F	; 0x80067f <pxOverflowDelayedTaskList+0x1>
 566:	6e 5f       	subi	r22, 0xFE	; 254
 568:	7f 4f       	sbci	r23, 0xFF	; 255
 56a:	0c de       	rcall	.-1000   	; 0x184 <vListInsert>
 56c:	16 c0       	rjmp	.+44     	; 0x59a <prvAddCurrentTaskToDelayedList+0x9c>
 56e:	60 91 b8 06 	lds	r22, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 572:	70 91 b9 06 	lds	r23, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 576:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <pxDelayedTaskList>
 57a:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 57e:	6e 5f       	subi	r22, 0xFE	; 254
 580:	7f 4f       	sbci	r23, 0xFF	; 255
 582:	00 de       	rcall	.-1024   	; 0x184 <vListInsert>
 584:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <xNextTaskUnblockTime>
 588:	90 91 58 06 	lds	r25, 0x0658	; 0x800658 <xNextTaskUnblockTime+0x1>
 58c:	c8 17       	cp	r28, r24
 58e:	d9 07       	cpc	r29, r25
 590:	20 f4       	brcc	.+8      	; 0x59a <prvAddCurrentTaskToDelayedList+0x9c>
 592:	d0 93 58 06 	sts	0x0658, r29	; 0x800658 <xNextTaskUnblockTime+0x1>
 596:	c0 93 57 06 	sts	0x0657, r28	; 0x800657 <xNextTaskUnblockTime>
 59a:	df 91       	pop	r29
 59c:	cf 91       	pop	r28
 59e:	1f 91       	pop	r17
 5a0:	0f 91       	pop	r16
 5a2:	ff 90       	pop	r15
 5a4:	08 95       	ret

000005a6 <xTaskCreate>:
 5a6:	4f 92       	push	r4
 5a8:	5f 92       	push	r5
 5aa:	6f 92       	push	r6
 5ac:	7f 92       	push	r7
 5ae:	8f 92       	push	r8
 5b0:	9f 92       	push	r9
 5b2:	af 92       	push	r10
 5b4:	bf 92       	push	r11
 5b6:	cf 92       	push	r12
 5b8:	df 92       	push	r13
 5ba:	ef 92       	push	r14
 5bc:	ff 92       	push	r15
 5be:	0f 93       	push	r16
 5c0:	cf 93       	push	r28
 5c2:	df 93       	push	r29
 5c4:	4c 01       	movw	r8, r24
 5c6:	6b 01       	movw	r12, r22
 5c8:	5a 01       	movw	r10, r20
 5ca:	29 01       	movw	r4, r18
 5cc:	ca 01       	movw	r24, r20
 5ce:	73 dd       	rcall	.-1306   	; 0xb6 <pvPortMalloc>
 5d0:	3c 01       	movw	r6, r24
 5d2:	89 2b       	or	r24, r25
 5d4:	09 f4       	brne	.+2      	; 0x5d8 <xTaskCreate+0x32>
 5d6:	d0 c0       	rjmp	.+416    	; 0x778 <xTaskCreate+0x1d2>
 5d8:	86 e2       	ldi	r24, 0x26	; 38
 5da:	90 e0       	ldi	r25, 0x00	; 0
 5dc:	6c dd       	rcall	.-1320   	; 0xb6 <pvPortMalloc>
 5de:	ec 01       	movw	r28, r24
 5e0:	89 2b       	or	r24, r25
 5e2:	59 f0       	breq	.+22     	; 0x5fa <xTaskCreate+0x54>
 5e4:	78 8e       	std	Y+24, r7	; 0x18
 5e6:	6f 8a       	std	Y+23, r6	; 0x17
 5e8:	81 e0       	ldi	r24, 0x01	; 1
 5ea:	a8 1a       	sub	r10, r24
 5ec:	b1 08       	sbc	r11, r1
 5ee:	a6 0c       	add	r10, r6
 5f0:	b7 1c       	adc	r11, r7
 5f2:	c1 14       	cp	r12, r1
 5f4:	d1 04       	cpc	r13, r1
 5f6:	21 f4       	brne	.+8      	; 0x600 <xTaskCreate+0x5a>
 5f8:	1f c0       	rjmp	.+62     	; 0x638 <xTaskCreate+0x92>
 5fa:	c3 01       	movw	r24, r6
 5fc:	8f dd       	rcall	.-1250   	; 0x11c <vPortFree>
 5fe:	bc c0       	rjmp	.+376    	; 0x778 <xTaskCreate+0x1d2>
 600:	d6 01       	movw	r26, r12
 602:	8c 91       	ld	r24, X
 604:	89 8f       	std	Y+25, r24	; 0x19
 606:	8c 91       	ld	r24, X
 608:	88 23       	and	r24, r24
 60a:	a1 f0       	breq	.+40     	; 0x634 <xTaskCreate+0x8e>
 60c:	ae 01       	movw	r20, r28
 60e:	46 5e       	subi	r20, 0xE6	; 230
 610:	5f 4f       	sbci	r21, 0xFF	; 255
 612:	f6 01       	movw	r30, r12
 614:	31 96       	adiw	r30, 0x01	; 1
 616:	b8 e0       	ldi	r27, 0x08	; 8
 618:	cb 0e       	add	r12, r27
 61a:	d1 1c       	adc	r13, r1
 61c:	cf 01       	movw	r24, r30
 61e:	21 91       	ld	r18, Z+
 620:	da 01       	movw	r26, r20
 622:	2d 93       	st	X+, r18
 624:	ad 01       	movw	r20, r26
 626:	dc 01       	movw	r26, r24
 628:	8c 91       	ld	r24, X
 62a:	88 23       	and	r24, r24
 62c:	19 f0       	breq	.+6      	; 0x634 <xTaskCreate+0x8e>
 62e:	ec 15       	cp	r30, r12
 630:	fd 05       	cpc	r31, r13
 632:	a1 f7       	brne	.-24     	; 0x61c <xTaskCreate+0x76>
 634:	18 a2       	std	Y+32, r1	; 0x20
 636:	01 c0       	rjmp	.+2      	; 0x63a <xTaskCreate+0x94>
 638:	19 8e       	std	Y+25, r1	; 0x19
 63a:	04 30       	cpi	r16, 0x04	; 4
 63c:	08 f0       	brcs	.+2      	; 0x640 <xTaskCreate+0x9a>
 63e:	03 e0       	ldi	r16, 0x03	; 3
 640:	0e 8b       	std	Y+22, r16	; 0x16
 642:	6e 01       	movw	r12, r28
 644:	b2 e0       	ldi	r27, 0x02	; 2
 646:	cb 0e       	add	r12, r27
 648:	d1 1c       	adc	r13, r1
 64a:	c6 01       	movw	r24, r12
 64c:	76 dd       	rcall	.-1300   	; 0x13a <vListInitialiseItem>
 64e:	ce 01       	movw	r24, r28
 650:	0c 96       	adiw	r24, 0x0c	; 12
 652:	73 dd       	rcall	.-1306   	; 0x13a <vListInitialiseItem>
 654:	d9 87       	std	Y+9, r29	; 0x09
 656:	c8 87       	std	Y+8, r28	; 0x08
 658:	84 e0       	ldi	r24, 0x04	; 4
 65a:	90 e0       	ldi	r25, 0x00	; 0
 65c:	80 1b       	sub	r24, r16
 65e:	91 09       	sbc	r25, r1
 660:	9d 87       	std	Y+13, r25	; 0x0d
 662:	8c 87       	std	Y+12, r24	; 0x0c
 664:	db 8b       	std	Y+19, r29	; 0x13
 666:	ca 8b       	std	Y+18, r28	; 0x12
 668:	19 a2       	std	Y+33, r1	; 0x21
 66a:	1a a2       	std	Y+34, r1	; 0x22
 66c:	1b a2       	std	Y+35, r1	; 0x23
 66e:	1c a2       	std	Y+36, r1	; 0x24
 670:	1d a2       	std	Y+37, r1	; 0x25
 672:	a2 01       	movw	r20, r4
 674:	b4 01       	movw	r22, r8
 676:	c5 01       	movw	r24, r10
 678:	dd dd       	rcall	.-1094   	; 0x234 <pxPortInitialiseStack>
 67a:	99 83       	std	Y+1, r25	; 0x01
 67c:	88 83       	st	Y, r24
 67e:	e1 14       	cp	r14, r1
 680:	f1 04       	cpc	r15, r1
 682:	19 f0       	breq	.+6      	; 0x68a <xTaskCreate+0xe4>
 684:	f7 01       	movw	r30, r14
 686:	d1 83       	std	Z+1, r29	; 0x01
 688:	c0 83       	st	Z, r28
 68a:	0f b6       	in	r0, 0x3f	; 63
 68c:	f8 94       	cli
 68e:	0f 92       	push	r0
 690:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 694:	8f 5f       	subi	r24, 0xFF	; 255
 696:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxCurrentNumberOfTasks>
 69a:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 69e:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 6a2:	89 2b       	or	r24, r25
 6a4:	89 f5       	brne	.+98     	; 0x708 <xTaskCreate+0x162>
 6a6:	d0 93 b9 06 	sts	0x06B9, r29	; 0x8006b9 <pxCurrentTCB+0x1>
 6aa:	c0 93 b8 06 	sts	0x06B8, r28	; 0x8006b8 <pxCurrentTCB>
 6ae:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 6b2:	81 30       	cpi	r24, 0x01	; 1
 6b4:	09 f0       	breq	.+2      	; 0x6b8 <xTaskCreate+0x112>
 6b6:	38 c0       	rjmp	.+112    	; 0x728 <xTaskCreate+0x182>
 6b8:	84 e9       	ldi	r24, 0x94	; 148
 6ba:	96 e0       	ldi	r25, 0x06	; 6
 6bc:	30 dd       	rcall	.-1440   	; 0x11e <vListInitialise>
 6be:	8d e9       	ldi	r24, 0x9D	; 157
 6c0:	96 e0       	ldi	r25, 0x06	; 6
 6c2:	2d dd       	rcall	.-1446   	; 0x11e <vListInitialise>
 6c4:	86 ea       	ldi	r24, 0xA6	; 166
 6c6:	96 e0       	ldi	r25, 0x06	; 6
 6c8:	2a dd       	rcall	.-1452   	; 0x11e <vListInitialise>
 6ca:	8f ea       	ldi	r24, 0xAF	; 175
 6cc:	96 e0       	ldi	r25, 0x06	; 6
 6ce:	27 dd       	rcall	.-1458   	; 0x11e <vListInitialise>
 6d0:	8b e8       	ldi	r24, 0x8B	; 139
 6d2:	96 e0       	ldi	r25, 0x06	; 6
 6d4:	24 dd       	rcall	.-1464   	; 0x11e <vListInitialise>
 6d6:	82 e8       	ldi	r24, 0x82	; 130
 6d8:	96 e0       	ldi	r25, 0x06	; 6
 6da:	21 dd       	rcall	.-1470   	; 0x11e <vListInitialise>
 6dc:	85 e7       	ldi	r24, 0x75	; 117
 6de:	96 e0       	ldi	r25, 0x06	; 6
 6e0:	1e dd       	rcall	.-1476   	; 0x11e <vListInitialise>
 6e2:	8c e6       	ldi	r24, 0x6C	; 108
 6e4:	96 e0       	ldi	r25, 0x06	; 6
 6e6:	1b dd       	rcall	.-1482   	; 0x11e <vListInitialise>
 6e8:	82 e6       	ldi	r24, 0x62	; 98
 6ea:	96 e0       	ldi	r25, 0x06	; 6
 6ec:	18 dd       	rcall	.-1488   	; 0x11e <vListInitialise>
 6ee:	8b e8       	ldi	r24, 0x8B	; 139
 6f0:	96 e0       	ldi	r25, 0x06	; 6
 6f2:	90 93 81 06 	sts	0x0681, r25	; 0x800681 <pxDelayedTaskList+0x1>
 6f6:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <pxDelayedTaskList>
 6fa:	82 e8       	ldi	r24, 0x82	; 130
 6fc:	96 e0       	ldi	r25, 0x06	; 6
 6fe:	90 93 7f 06 	sts	0x067F, r25	; 0x80067f <pxOverflowDelayedTaskList+0x1>
 702:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <pxOverflowDelayedTaskList>
 706:	10 c0       	rjmp	.+32     	; 0x728 <xTaskCreate+0x182>
 708:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <xSchedulerRunning>
 70c:	81 11       	cpse	r24, r1
 70e:	0c c0       	rjmp	.+24     	; 0x728 <xTaskCreate+0x182>
 710:	e0 91 b8 06 	lds	r30, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 714:	f0 91 b9 06 	lds	r31, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 718:	96 89       	ldd	r25, Z+22	; 0x16
 71a:	8e 89       	ldd	r24, Y+22	; 0x16
 71c:	89 17       	cp	r24, r25
 71e:	20 f0       	brcs	.+8      	; 0x728 <xTaskCreate+0x182>
 720:	d0 93 b9 06 	sts	0x06B9, r29	; 0x8006b9 <pxCurrentTCB+0x1>
 724:	c0 93 b8 06 	sts	0x06B8, r28	; 0x8006b8 <pxCurrentTCB>
 728:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <uxTaskNumber>
 72c:	8f 5f       	subi	r24, 0xFF	; 255
 72e:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <uxTaskNumber>
 732:	8e 89       	ldd	r24, Y+22	; 0x16
 734:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTopReadyPriority>
 738:	98 17       	cp	r25, r24
 73a:	10 f4       	brcc	.+4      	; 0x740 <xTaskCreate+0x19a>
 73c:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 740:	90 e0       	ldi	r25, 0x00	; 0
 742:	9c 01       	movw	r18, r24
 744:	22 0f       	add	r18, r18
 746:	33 1f       	adc	r19, r19
 748:	22 0f       	add	r18, r18
 74a:	33 1f       	adc	r19, r19
 74c:	22 0f       	add	r18, r18
 74e:	33 1f       	adc	r19, r19
 750:	82 0f       	add	r24, r18
 752:	93 1f       	adc	r25, r19
 754:	b6 01       	movw	r22, r12
 756:	8c 56       	subi	r24, 0x6C	; 108
 758:	99 4f       	sbci	r25, 0xF9	; 249
 75a:	f3 dc       	rcall	.-1562   	; 0x142 <vListInsertEnd>
 75c:	0f 90       	pop	r0
 75e:	0f be       	out	0x3f, r0	; 63
 760:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <xSchedulerRunning>
 764:	88 23       	and	r24, r24
 766:	31 f0       	breq	.+12     	; 0x774 <xTaskCreate+0x1ce>
 768:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 76c:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 770:	81 e0       	ldi	r24, 0x01	; 1
 772:	03 c0       	rjmp	.+6      	; 0x77a <xTaskCreate+0x1d4>
 774:	81 e0       	ldi	r24, 0x01	; 1
 776:	01 c0       	rjmp	.+2      	; 0x77a <xTaskCreate+0x1d4>
 778:	8f ef       	ldi	r24, 0xFF	; 255
 77a:	df 91       	pop	r29
 77c:	cf 91       	pop	r28
 77e:	0f 91       	pop	r16
 780:	ff 90       	pop	r15
 782:	ef 90       	pop	r14
 784:	df 90       	pop	r13
 786:	cf 90       	pop	r12
 788:	bf 90       	pop	r11
 78a:	af 90       	pop	r10
 78c:	9f 90       	pop	r9
 78e:	8f 90       	pop	r8
 790:	7f 90       	pop	r7
 792:	6f 90       	pop	r6
 794:	5f 90       	pop	r5
 796:	4f 90       	pop	r4
 798:	08 95       	ret

0000079a <vTaskDelete>:
 79a:	0f 93       	push	r16
 79c:	1f 93       	push	r17
 79e:	cf 93       	push	r28
 7a0:	df 93       	push	r29
 7a2:	ec 01       	movw	r28, r24
 7a4:	0f b6       	in	r0, 0x3f	; 63
 7a6:	f8 94       	cli
 7a8:	0f 92       	push	r0
 7aa:	89 2b       	or	r24, r25
 7ac:	21 f4       	brne	.+8      	; 0x7b6 <vTaskDelete+0x1c>
 7ae:	c0 91 b8 06 	lds	r28, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 7b2:	d0 91 b9 06 	lds	r29, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 7b6:	8e 01       	movw	r16, r28
 7b8:	0e 5f       	subi	r16, 0xFE	; 254
 7ba:	1f 4f       	sbci	r17, 0xFF	; 255
 7bc:	c8 01       	movw	r24, r16
 7be:	13 dd       	rcall	.-1498   	; 0x1e6 <uxListRemove>
 7c0:	8c 89       	ldd	r24, Y+20	; 0x14
 7c2:	9d 89       	ldd	r25, Y+21	; 0x15
 7c4:	89 2b       	or	r24, r25
 7c6:	19 f0       	breq	.+6      	; 0x7ce <vTaskDelete+0x34>
 7c8:	ce 01       	movw	r24, r28
 7ca:	0c 96       	adiw	r24, 0x0c	; 12
 7cc:	0c dd       	rcall	.-1512   	; 0x1e6 <uxListRemove>
 7ce:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <uxTaskNumber>
 7d2:	8f 5f       	subi	r24, 0xFF	; 255
 7d4:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <uxTaskNumber>
 7d8:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 7dc:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 7e0:	c8 17       	cp	r28, r24
 7e2:	d9 07       	cpc	r29, r25
 7e4:	51 f4       	brne	.+20     	; 0x7fa <vTaskDelete+0x60>
 7e6:	b8 01       	movw	r22, r16
 7e8:	8c e6       	ldi	r24, 0x6C	; 108
 7ea:	96 e0       	ldi	r25, 0x06	; 6
 7ec:	aa dc       	rcall	.-1708   	; 0x142 <vListInsertEnd>
 7ee:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <uxDeletedTasksWaitingCleanUp>
 7f2:	8f 5f       	subi	r24, 0xFF	; 255
 7f4:	80 93 6b 06 	sts	0x066B, r24	; 0x80066b <uxDeletedTasksWaitingCleanUp>
 7f8:	0b c0       	rjmp	.+22     	; 0x810 <vTaskDelete+0x76>
 7fa:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 7fe:	81 50       	subi	r24, 0x01	; 1
 800:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxCurrentNumberOfTasks>
 804:	8f 89       	ldd	r24, Y+23	; 0x17
 806:	98 8d       	ldd	r25, Y+24	; 0x18
 808:	89 dc       	rcall	.-1774   	; 0x11c <vPortFree>
 80a:	ce 01       	movw	r24, r28
 80c:	87 dc       	rcall	.-1778   	; 0x11c <vPortFree>
 80e:	2e de       	rcall	.-932    	; 0x46c <prvResetNextTaskUnblockTime>
 810:	0f 90       	pop	r0
 812:	0f be       	out	0x3f, r0	; 63
 814:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <xSchedulerRunning>
 818:	88 23       	and	r24, r24
 81a:	41 f0       	breq	.+16     	; 0x82c <vTaskDelete+0x92>
 81c:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 820:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 824:	c8 17       	cp	r28, r24
 826:	d9 07       	cpc	r29, r25
 828:	09 f4       	brne	.+2      	; 0x82c <vTaskDelete+0x92>
 82a:	a5 dd       	rcall	.-1206   	; 0x376 <vPortYield>
 82c:	df 91       	pop	r29
 82e:	cf 91       	pop	r28
 830:	1f 91       	pop	r17
 832:	0f 91       	pop	r16
 834:	08 95       	ret

00000836 <vTaskStartScheduler>:
 836:	ef 92       	push	r14
 838:	ff 92       	push	r15
 83a:	0f 93       	push	r16
 83c:	0f 2e       	mov	r0, r31
 83e:	f5 e5       	ldi	r31, 0x55	; 85
 840:	ef 2e       	mov	r14, r31
 842:	f6 e0       	ldi	r31, 0x06	; 6
 844:	ff 2e       	mov	r15, r31
 846:	f0 2d       	mov	r31, r0
 848:	00 e0       	ldi	r16, 0x00	; 0
 84a:	20 e0       	ldi	r18, 0x00	; 0
 84c:	30 e0       	ldi	r19, 0x00	; 0
 84e:	45 e5       	ldi	r20, 0x55	; 85
 850:	50 e0       	ldi	r21, 0x00	; 0
 852:	60 e6       	ldi	r22, 0x60	; 96
 854:	70 e0       	ldi	r23, 0x00	; 0
 856:	85 e5       	ldi	r24, 0x55	; 85
 858:	92 e0       	ldi	r25, 0x02	; 2
 85a:	a5 de       	rcall	.-694    	; 0x5a6 <xTaskCreate>
 85c:	81 30       	cpi	r24, 0x01	; 1
 85e:	79 f4       	brne	.+30     	; 0x87e <__stack+0x1f>
 860:	f8 94       	cli
 862:	8f ef       	ldi	r24, 0xFF	; 255
 864:	9f ef       	ldi	r25, 0xFF	; 255
 866:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 86a:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 86e:	81 e0       	ldi	r24, 0x01	; 1
 870:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <xSchedulerRunning>
 874:	10 92 60 06 	sts	0x0660, r1	; 0x800660 <xTickCount+0x1>
 878:	10 92 5f 06 	sts	0x065F, r1	; 0x80065f <xTickCount>
 87c:	47 dd       	rcall	.-1394   	; 0x30c <xPortStartScheduler>
 87e:	0f 91       	pop	r16
 880:	ff 90       	pop	r15
 882:	ef 90       	pop	r14
 884:	08 95       	ret

00000886 <vTaskSuspendAll>:
 886:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 88a:	8f 5f       	subi	r24, 0xFF	; 255
 88c:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <uxSchedulerSuspended>
 890:	08 95       	ret

00000892 <xTaskGetTickCount>:
 892:	0f b6       	in	r0, 0x3f	; 63
 894:	f8 94       	cli
 896:	0f 92       	push	r0
 898:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xTickCount>
 89c:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <xTickCount+0x1>
 8a0:	0f 90       	pop	r0
 8a2:	0f be       	out	0x3f, r0	; 63
 8a4:	08 95       	ret

000008a6 <xTaskIncrementTick>:
 8a6:	ef 92       	push	r14
 8a8:	ff 92       	push	r15
 8aa:	0f 93       	push	r16
 8ac:	1f 93       	push	r17
 8ae:	cf 93       	push	r28
 8b0:	df 93       	push	r29
 8b2:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 8b6:	81 11       	cpse	r24, r1
 8b8:	85 c0       	rjmp	.+266    	; 0x9c4 <xTaskIncrementTick+0x11e>
 8ba:	e0 90 5f 06 	lds	r14, 0x065F	; 0x80065f <xTickCount>
 8be:	f0 90 60 06 	lds	r15, 0x0660	; 0x800660 <xTickCount+0x1>
 8c2:	8f ef       	ldi	r24, 0xFF	; 255
 8c4:	e8 1a       	sub	r14, r24
 8c6:	f8 0a       	sbc	r15, r24
 8c8:	f0 92 60 06 	sts	0x0660, r15	; 0x800660 <xTickCount+0x1>
 8cc:	e0 92 5f 06 	sts	0x065F, r14	; 0x80065f <xTickCount>
 8d0:	e1 14       	cp	r14, r1
 8d2:	f1 04       	cpc	r15, r1
 8d4:	b1 f4       	brne	.+44     	; 0x902 <xTaskIncrementTick+0x5c>
 8d6:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <pxDelayedTaskList>
 8da:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 8de:	20 91 7e 06 	lds	r18, 0x067E	; 0x80067e <pxOverflowDelayedTaskList>
 8e2:	30 91 7f 06 	lds	r19, 0x067F	; 0x80067f <pxOverflowDelayedTaskList+0x1>
 8e6:	30 93 81 06 	sts	0x0681, r19	; 0x800681 <pxDelayedTaskList+0x1>
 8ea:	20 93 80 06 	sts	0x0680, r18	; 0x800680 <pxDelayedTaskList>
 8ee:	90 93 7f 06 	sts	0x067F, r25	; 0x80067f <pxOverflowDelayedTaskList+0x1>
 8f2:	80 93 7e 06 	sts	0x067E, r24	; 0x80067e <pxOverflowDelayedTaskList>
 8f6:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <xNumOfOverflows>
 8fa:	8f 5f       	subi	r24, 0xFF	; 255
 8fc:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <xNumOfOverflows>
 900:	b5 dd       	rcall	.-1174   	; 0x46c <prvResetNextTaskUnblockTime>
 902:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <xNextTaskUnblockTime>
 906:	90 91 58 06 	lds	r25, 0x0658	; 0x800658 <xNextTaskUnblockTime+0x1>
 90a:	e8 16       	cp	r14, r24
 90c:	f9 06       	cpc	r15, r25
 90e:	08 f4       	brcc	.+2      	; 0x912 <xTaskIncrementTick+0x6c>
 910:	5e c0       	rjmp	.+188    	; 0x9ce <xTaskIncrementTick+0x128>
 912:	e0 91 80 06 	lds	r30, 0x0680	; 0x800680 <pxDelayedTaskList>
 916:	f0 91 81 06 	lds	r31, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 91a:	80 81       	ld	r24, Z
 91c:	88 23       	and	r24, r24
 91e:	79 f0       	breq	.+30     	; 0x93e <xTaskIncrementTick+0x98>
 920:	e0 91 80 06 	lds	r30, 0x0680	; 0x800680 <pxDelayedTaskList>
 924:	f0 91 81 06 	lds	r31, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 928:	05 80       	ldd	r0, Z+5	; 0x05
 92a:	f6 81       	ldd	r31, Z+6	; 0x06
 92c:	e0 2d       	mov	r30, r0
 92e:	c6 81       	ldd	r28, Z+6	; 0x06
 930:	d7 81       	ldd	r29, Z+7	; 0x07
 932:	8a 81       	ldd	r24, Y+2	; 0x02
 934:	9b 81       	ldd	r25, Y+3	; 0x03
 936:	e8 16       	cp	r14, r24
 938:	f9 06       	cpc	r15, r25
 93a:	d8 f4       	brcc	.+54     	; 0x972 <xTaskIncrementTick+0xcc>
 93c:	15 c0       	rjmp	.+42     	; 0x968 <xTaskIncrementTick+0xc2>
 93e:	8f ef       	ldi	r24, 0xFF	; 255
 940:	9f ef       	ldi	r25, 0xFF	; 255
 942:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 946:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 94a:	41 c0       	rjmp	.+130    	; 0x9ce <xTaskIncrementTick+0x128>
 94c:	e0 91 80 06 	lds	r30, 0x0680	; 0x800680 <pxDelayedTaskList>
 950:	f0 91 81 06 	lds	r31, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 954:	05 80       	ldd	r0, Z+5	; 0x05
 956:	f6 81       	ldd	r31, Z+6	; 0x06
 958:	e0 2d       	mov	r30, r0
 95a:	c6 81       	ldd	r28, Z+6	; 0x06
 95c:	d7 81       	ldd	r29, Z+7	; 0x07
 95e:	8a 81       	ldd	r24, Y+2	; 0x02
 960:	9b 81       	ldd	r25, Y+3	; 0x03
 962:	e8 16       	cp	r14, r24
 964:	f9 06       	cpc	r15, r25
 966:	28 f4       	brcc	.+10     	; 0x972 <xTaskIncrementTick+0xcc>
 968:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 96c:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 970:	2e c0       	rjmp	.+92     	; 0x9ce <xTaskIncrementTick+0x128>
 972:	8e 01       	movw	r16, r28
 974:	0e 5f       	subi	r16, 0xFE	; 254
 976:	1f 4f       	sbci	r17, 0xFF	; 255
 978:	c8 01       	movw	r24, r16
 97a:	35 dc       	rcall	.-1942   	; 0x1e6 <uxListRemove>
 97c:	8c 89       	ldd	r24, Y+20	; 0x14
 97e:	9d 89       	ldd	r25, Y+21	; 0x15
 980:	89 2b       	or	r24, r25
 982:	19 f0       	breq	.+6      	; 0x98a <xTaskIncrementTick+0xe4>
 984:	ce 01       	movw	r24, r28
 986:	0c 96       	adiw	r24, 0x0c	; 12
 988:	2e dc       	rcall	.-1956   	; 0x1e6 <uxListRemove>
 98a:	8e 89       	ldd	r24, Y+22	; 0x16
 98c:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTopReadyPriority>
 990:	98 17       	cp	r25, r24
 992:	10 f4       	brcc	.+4      	; 0x998 <xTaskIncrementTick+0xf2>
 994:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 998:	90 e0       	ldi	r25, 0x00	; 0
 99a:	9c 01       	movw	r18, r24
 99c:	22 0f       	add	r18, r18
 99e:	33 1f       	adc	r19, r19
 9a0:	22 0f       	add	r18, r18
 9a2:	33 1f       	adc	r19, r19
 9a4:	22 0f       	add	r18, r18
 9a6:	33 1f       	adc	r19, r19
 9a8:	82 0f       	add	r24, r18
 9aa:	93 1f       	adc	r25, r19
 9ac:	b8 01       	movw	r22, r16
 9ae:	8c 56       	subi	r24, 0x6C	; 108
 9b0:	99 4f       	sbci	r25, 0xF9	; 249
 9b2:	c7 db       	rcall	.-2162   	; 0x142 <vListInsertEnd>
 9b4:	e0 91 80 06 	lds	r30, 0x0680	; 0x800680 <pxDelayedTaskList>
 9b8:	f0 91 81 06 	lds	r31, 0x0681	; 0x800681 <pxDelayedTaskList+0x1>
 9bc:	80 81       	ld	r24, Z
 9be:	81 11       	cpse	r24, r1
 9c0:	c5 cf       	rjmp	.-118    	; 0x94c <xTaskIncrementTick+0xa6>
 9c2:	bd cf       	rjmp	.-134    	; 0x93e <xTaskIncrementTick+0x98>
 9c4:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <uxPendedTicks>
 9c8:	8f 5f       	subi	r24, 0xFF	; 255
 9ca:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <uxPendedTicks>
 9ce:	80 e0       	ldi	r24, 0x00	; 0
 9d0:	df 91       	pop	r29
 9d2:	cf 91       	pop	r28
 9d4:	1f 91       	pop	r17
 9d6:	0f 91       	pop	r16
 9d8:	ff 90       	pop	r15
 9da:	ef 90       	pop	r14
 9dc:	08 95       	ret

000009de <xTaskResumeAll>:
 9de:	df 92       	push	r13
 9e0:	ef 92       	push	r14
 9e2:	ff 92       	push	r15
 9e4:	0f 93       	push	r16
 9e6:	1f 93       	push	r17
 9e8:	cf 93       	push	r28
 9ea:	df 93       	push	r29
 9ec:	0f b6       	in	r0, 0x3f	; 63
 9ee:	f8 94       	cli
 9f0:	0f 92       	push	r0
 9f2:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 9f6:	81 50       	subi	r24, 0x01	; 1
 9f8:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <uxSchedulerSuspended>
 9fc:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 a00:	81 11       	cpse	r24, r1
 a02:	54 c0       	rjmp	.+168    	; 0xaac <xTaskResumeAll+0xce>
 a04:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 a08:	81 11       	cpse	r24, r1
 a0a:	30 c0       	rjmp	.+96     	; 0xa6c <xTaskResumeAll+0x8e>
 a0c:	4f c0       	rjmp	.+158    	; 0xaac <xTaskResumeAll+0xce>
 a0e:	d7 01       	movw	r26, r14
 a10:	15 96       	adiw	r26, 0x05	; 5
 a12:	ed 91       	ld	r30, X+
 a14:	fc 91       	ld	r31, X
 a16:	16 97       	sbiw	r26, 0x06	; 6
 a18:	c6 81       	ldd	r28, Z+6	; 0x06
 a1a:	d7 81       	ldd	r29, Z+7	; 0x07
 a1c:	ce 01       	movw	r24, r28
 a1e:	0c 96       	adiw	r24, 0x0c	; 12
 a20:	e2 db       	rcall	.-2108   	; 0x1e6 <uxListRemove>
 a22:	8e 01       	movw	r16, r28
 a24:	0e 5f       	subi	r16, 0xFE	; 254
 a26:	1f 4f       	sbci	r17, 0xFF	; 255
 a28:	c8 01       	movw	r24, r16
 a2a:	dd db       	rcall	.-2118   	; 0x1e6 <uxListRemove>
 a2c:	8e 89       	ldd	r24, Y+22	; 0x16
 a2e:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTopReadyPriority>
 a32:	98 17       	cp	r25, r24
 a34:	10 f4       	brcc	.+4      	; 0xa3a <xTaskResumeAll+0x5c>
 a36:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 a3a:	90 e0       	ldi	r25, 0x00	; 0
 a3c:	9c 01       	movw	r18, r24
 a3e:	22 0f       	add	r18, r18
 a40:	33 1f       	adc	r19, r19
 a42:	22 0f       	add	r18, r18
 a44:	33 1f       	adc	r19, r19
 a46:	22 0f       	add	r18, r18
 a48:	33 1f       	adc	r19, r19
 a4a:	82 0f       	add	r24, r18
 a4c:	93 1f       	adc	r25, r19
 a4e:	b8 01       	movw	r22, r16
 a50:	8c 56       	subi	r24, 0x6C	; 108
 a52:	99 4f       	sbci	r25, 0xF9	; 249
 a54:	76 db       	rcall	.-2324   	; 0x142 <vListInsertEnd>
 a56:	e0 91 b8 06 	lds	r30, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 a5a:	f0 91 b9 06 	lds	r31, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>
 a5e:	9e 89       	ldd	r25, Y+22	; 0x16
 a60:	86 89       	ldd	r24, Z+22	; 0x16
 a62:	98 17       	cp	r25, r24
 a64:	68 f0       	brcs	.+26     	; 0xa80 <xTaskResumeAll+0xa2>
 a66:	d0 92 5b 06 	sts	0x065B, r13	; 0x80065b <xYieldPending>
 a6a:	0a c0       	rjmp	.+20     	; 0xa80 <xTaskResumeAll+0xa2>
 a6c:	c0 e0       	ldi	r28, 0x00	; 0
 a6e:	d0 e0       	ldi	r29, 0x00	; 0
 a70:	0f 2e       	mov	r0, r31
 a72:	f5 e7       	ldi	r31, 0x75	; 117
 a74:	ef 2e       	mov	r14, r31
 a76:	f6 e0       	ldi	r31, 0x06	; 6
 a78:	ff 2e       	mov	r15, r31
 a7a:	f0 2d       	mov	r31, r0
 a7c:	dd 24       	eor	r13, r13
 a7e:	d3 94       	inc	r13
 a80:	f7 01       	movw	r30, r14
 a82:	80 81       	ld	r24, Z
 a84:	81 11       	cpse	r24, r1
 a86:	c3 cf       	rjmp	.-122    	; 0xa0e <xTaskResumeAll+0x30>
 a88:	cd 2b       	or	r28, r29
 a8a:	09 f0       	breq	.+2      	; 0xa8e <xTaskResumeAll+0xb0>
 a8c:	ef dc       	rcall	.-1570   	; 0x46c <prvResetNextTaskUnblockTime>
 a8e:	c0 91 5c 06 	lds	r28, 0x065C	; 0x80065c <uxPendedTicks>
 a92:	cc 23       	and	r28, r28
 a94:	49 f0       	breq	.+18     	; 0xaa8 <xTaskResumeAll+0xca>
 a96:	d1 e0       	ldi	r29, 0x01	; 1
 a98:	06 df       	rcall	.-500    	; 0x8a6 <xTaskIncrementTick>
 a9a:	81 11       	cpse	r24, r1
 a9c:	d0 93 5b 06 	sts	0x065B, r29	; 0x80065b <xYieldPending>
 aa0:	c1 50       	subi	r28, 0x01	; 1
 aa2:	d1 f7       	brne	.-12     	; 0xa98 <xTaskResumeAll+0xba>
 aa4:	10 92 5c 06 	sts	0x065C, r1	; 0x80065c <uxPendedTicks>
 aa8:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xYieldPending>
 aac:	0f 90       	pop	r0
 aae:	0f be       	out	0x3f, r0	; 63
 ab0:	80 e0       	ldi	r24, 0x00	; 0
 ab2:	df 91       	pop	r29
 ab4:	cf 91       	pop	r28
 ab6:	1f 91       	pop	r17
 ab8:	0f 91       	pop	r16
 aba:	ff 90       	pop	r15
 abc:	ef 90       	pop	r14
 abe:	df 90       	pop	r13
 ac0:	08 95       	ret

00000ac2 <vTaskDelayUntil>:
 ac2:	0f 93       	push	r16
 ac4:	1f 93       	push	r17
 ac6:	cf 93       	push	r28
 ac8:	df 93       	push	r29
 aca:	8c 01       	movw	r16, r24
 acc:	eb 01       	movw	r28, r22
 ace:	db de       	rcall	.-586    	; 0x886 <vTaskSuspendAll>
 ad0:	40 91 5f 06 	lds	r20, 0x065F	; 0x80065f <xTickCount>
 ad4:	50 91 60 06 	lds	r21, 0x0660	; 0x800660 <xTickCount+0x1>
 ad8:	f8 01       	movw	r30, r16
 ada:	20 81       	ld	r18, Z
 adc:	31 81       	ldd	r19, Z+1	; 0x01
 ade:	c9 01       	movw	r24, r18
 ae0:	8c 0f       	add	r24, r28
 ae2:	9d 1f       	adc	r25, r29
 ae4:	42 17       	cp	r20, r18
 ae6:	53 07       	cpc	r21, r19
 ae8:	48 f4       	brcc	.+18     	; 0xafc <vTaskDelayUntil+0x3a>
 aea:	82 17       	cp	r24, r18
 aec:	93 07       	cpc	r25, r19
 aee:	d0 f4       	brcc	.+52     	; 0xb24 <vTaskDelayUntil+0x62>
 af0:	91 83       	std	Z+1, r25	; 0x01
 af2:	80 83       	st	Z, r24
 af4:	48 17       	cp	r20, r24
 af6:	59 07       	cpc	r21, r25
 af8:	60 f4       	brcc	.+24     	; 0xb12 <vTaskDelayUntil+0x50>
 afa:	07 c0       	rjmp	.+14     	; 0xb0a <vTaskDelayUntil+0x48>
 afc:	82 17       	cp	r24, r18
 afe:	93 07       	cpc	r25, r19
 b00:	68 f0       	brcs	.+26     	; 0xb1c <vTaskDelayUntil+0x5a>
 b02:	48 17       	cp	r20, r24
 b04:	59 07       	cpc	r21, r25
 b06:	50 f0       	brcs	.+20     	; 0xb1c <vTaskDelayUntil+0x5a>
 b08:	0d c0       	rjmp	.+26     	; 0xb24 <vTaskDelayUntil+0x62>
 b0a:	60 e0       	ldi	r22, 0x00	; 0
 b0c:	84 1b       	sub	r24, r20
 b0e:	95 0b       	sbc	r25, r21
 b10:	f6 dc       	rcall	.-1556   	; 0x4fe <prvAddCurrentTaskToDelayedList>
 b12:	65 df       	rcall	.-310    	; 0x9de <xTaskResumeAll>
 b14:	81 11       	cpse	r24, r1
 b16:	0a c0       	rjmp	.+20     	; 0xb2c <vTaskDelayUntil+0x6a>
 b18:	2e dc       	rcall	.-1956   	; 0x376 <vPortYield>
 b1a:	08 c0       	rjmp	.+16     	; 0xb2c <vTaskDelayUntil+0x6a>
 b1c:	f8 01       	movw	r30, r16
 b1e:	91 83       	std	Z+1, r25	; 0x01
 b20:	80 83       	st	Z, r24
 b22:	f3 cf       	rjmp	.-26     	; 0xb0a <vTaskDelayUntil+0x48>
 b24:	f8 01       	movw	r30, r16
 b26:	91 83       	std	Z+1, r25	; 0x01
 b28:	80 83       	st	Z, r24
 b2a:	f3 cf       	rjmp	.-26     	; 0xb12 <vTaskDelayUntil+0x50>
 b2c:	df 91       	pop	r29
 b2e:	cf 91       	pop	r28
 b30:	1f 91       	pop	r17
 b32:	0f 91       	pop	r16
 b34:	08 95       	ret

00000b36 <vTaskSwitchContext>:
 b36:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 b3a:	88 23       	and	r24, r24
 b3c:	21 f0       	breq	.+8      	; 0xb46 <vTaskSwitchContext+0x10>
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	80 93 5b 06 	sts	0x065B, r24	; 0x80065b <xYieldPending>
 b44:	08 95       	ret
 b46:	10 92 5b 06 	sts	0x065B, r1	; 0x80065b <xYieldPending>
 b4a:	20 91 5e 06 	lds	r18, 0x065E	; 0x80065e <uxTopReadyPriority>
 b4e:	82 2f       	mov	r24, r18
 b50:	90 e0       	ldi	r25, 0x00	; 0
 b52:	fc 01       	movw	r30, r24
 b54:	ee 0f       	add	r30, r30
 b56:	ff 1f       	adc	r31, r31
 b58:	ee 0f       	add	r30, r30
 b5a:	ff 1f       	adc	r31, r31
 b5c:	ee 0f       	add	r30, r30
 b5e:	ff 1f       	adc	r31, r31
 b60:	e8 0f       	add	r30, r24
 b62:	f9 1f       	adc	r31, r25
 b64:	ec 56       	subi	r30, 0x6C	; 108
 b66:	f9 4f       	sbci	r31, 0xF9	; 249
 b68:	30 81       	ld	r19, Z
 b6a:	31 11       	cpse	r19, r1
 b6c:	11 c0       	rjmp	.+34     	; 0xb90 <vTaskSwitchContext+0x5a>
 b6e:	21 50       	subi	r18, 0x01	; 1
 b70:	82 2f       	mov	r24, r18
 b72:	90 e0       	ldi	r25, 0x00	; 0
 b74:	fc 01       	movw	r30, r24
 b76:	ee 0f       	add	r30, r30
 b78:	ff 1f       	adc	r31, r31
 b7a:	ee 0f       	add	r30, r30
 b7c:	ff 1f       	adc	r31, r31
 b7e:	ee 0f       	add	r30, r30
 b80:	ff 1f       	adc	r31, r31
 b82:	e8 0f       	add	r30, r24
 b84:	f9 1f       	adc	r31, r25
 b86:	ec 56       	subi	r30, 0x6C	; 108
 b88:	f9 4f       	sbci	r31, 0xF9	; 249
 b8a:	30 81       	ld	r19, Z
 b8c:	33 23       	and	r19, r19
 b8e:	79 f3       	breq	.-34     	; 0xb6e <vTaskSwitchContext+0x38>
 b90:	ac 01       	movw	r20, r24
 b92:	44 0f       	add	r20, r20
 b94:	55 1f       	adc	r21, r21
 b96:	44 0f       	add	r20, r20
 b98:	55 1f       	adc	r21, r21
 b9a:	44 0f       	add	r20, r20
 b9c:	55 1f       	adc	r21, r21
 b9e:	48 0f       	add	r20, r24
 ba0:	59 1f       	adc	r21, r25
 ba2:	da 01       	movw	r26, r20
 ba4:	ac 56       	subi	r26, 0x6C	; 108
 ba6:	b9 4f       	sbci	r27, 0xF9	; 249
 ba8:	11 96       	adiw	r26, 0x01	; 1
 baa:	ed 91       	ld	r30, X+
 bac:	fc 91       	ld	r31, X
 bae:	12 97       	sbiw	r26, 0x02	; 2
 bb0:	02 80       	ldd	r0, Z+2	; 0x02
 bb2:	f3 81       	ldd	r31, Z+3	; 0x03
 bb4:	e0 2d       	mov	r30, r0
 bb6:	12 96       	adiw	r26, 0x02	; 2
 bb8:	fc 93       	st	X, r31
 bba:	ee 93       	st	-X, r30
 bbc:	11 97       	sbiw	r26, 0x01	; 1
 bbe:	49 56       	subi	r20, 0x69	; 105
 bc0:	59 4f       	sbci	r21, 0xF9	; 249
 bc2:	e4 17       	cp	r30, r20
 bc4:	f5 07       	cpc	r31, r21
 bc6:	29 f4       	brne	.+10     	; 0xbd2 <vTaskSwitchContext+0x9c>
 bc8:	42 81       	ldd	r20, Z+2	; 0x02
 bca:	53 81       	ldd	r21, Z+3	; 0x03
 bcc:	fd 01       	movw	r30, r26
 bce:	52 83       	std	Z+2, r21	; 0x02
 bd0:	41 83       	std	Z+1, r20	; 0x01
 bd2:	fc 01       	movw	r30, r24
 bd4:	ee 0f       	add	r30, r30
 bd6:	ff 1f       	adc	r31, r31
 bd8:	ee 0f       	add	r30, r30
 bda:	ff 1f       	adc	r31, r31
 bdc:	ee 0f       	add	r30, r30
 bde:	ff 1f       	adc	r31, r31
 be0:	8e 0f       	add	r24, r30
 be2:	9f 1f       	adc	r25, r31
 be4:	fc 01       	movw	r30, r24
 be6:	ec 56       	subi	r30, 0x6C	; 108
 be8:	f9 4f       	sbci	r31, 0xF9	; 249
 bea:	01 80       	ldd	r0, Z+1	; 0x01
 bec:	f2 81       	ldd	r31, Z+2	; 0x02
 bee:	e0 2d       	mov	r30, r0
 bf0:	86 81       	ldd	r24, Z+6	; 0x06
 bf2:	97 81       	ldd	r25, Z+7	; 0x07
 bf4:	90 93 b9 06 	sts	0x06B9, r25	; 0x8006b9 <pxCurrentTCB+0x1>
 bf8:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <pxCurrentTCB>
 bfc:	20 93 5e 06 	sts	0x065E, r18	; 0x80065e <uxTopReadyPriority>
 c00:	08 95       	ret

00000c02 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 c02:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <pxCurrentTCB>
 c06:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <pxCurrentTCB+0x1>

		return xReturn;
	}
 c0a:	08 95       	ret

00000c0c <Led_Init>:
		break;
	case LED_2:
		DIO_Write(LED_2_GPIO, LED_2_BIT, LOW);
		break;
	case LED_3:
		DIO_Write(LED_3_GPIO, LED_3_BIT, LOW);
 c0c:	cf 93       	push	r28
 c0e:	df 93       	push	r29
 c10:	00 d0       	rcall	.+0      	; 0xc12 <Led_Init+0x6>
 c12:	1f 92       	push	r1
 c14:	cd b7       	in	r28, 0x3d	; 61
 c16:	de b7       	in	r29, 0x3e	; 62
 c18:	81 30       	cpi	r24, 0x01	; 1
 c1a:	69 f0       	breq	.+26     	; 0xc36 <Led_Init+0x2a>
 c1c:	28 f0       	brcs	.+10     	; 0xc28 <Led_Init+0x1c>
 c1e:	82 30       	cpi	r24, 0x02	; 2
 c20:	89 f0       	breq	.+34     	; 0xc44 <Led_Init+0x38>
 c22:	83 30       	cpi	r24, 0x03	; 3
 c24:	b1 f0       	breq	.+44     	; 0xc52 <Led_Init+0x46>
 c26:	1b c0       	rjmp	.+54     	; 0xc5e <Led_Init+0x52>
 c28:	81 e0       	ldi	r24, 0x01	; 1
 c2a:	89 83       	std	Y+1, r24	; 0x01
 c2c:	80 e1       	ldi	r24, 0x10	; 16
 c2e:	8a 83       	std	Y+2, r24	; 0x02
 c30:	8f ef       	ldi	r24, 0xFF	; 255
 c32:	8b 83       	std	Y+3, r24	; 0x03
 c34:	14 c0       	rjmp	.+40     	; 0xc5e <Led_Init+0x52>
 c36:	81 e0       	ldi	r24, 0x01	; 1
 c38:	89 83       	std	Y+1, r24	; 0x01
 c3a:	80 e2       	ldi	r24, 0x20	; 32
 c3c:	8a 83       	std	Y+2, r24	; 0x02
 c3e:	8f ef       	ldi	r24, 0xFF	; 255
 c40:	8b 83       	std	Y+3, r24	; 0x03
 c42:	0d c0       	rjmp	.+26     	; 0xc5e <Led_Init+0x52>
 c44:	81 e0       	ldi	r24, 0x01	; 1
 c46:	89 83       	std	Y+1, r24	; 0x01
 c48:	80 e4       	ldi	r24, 0x40	; 64
 c4a:	8a 83       	std	Y+2, r24	; 0x02
 c4c:	8f ef       	ldi	r24, 0xFF	; 255
 c4e:	8b 83       	std	Y+3, r24	; 0x03
 c50:	06 c0       	rjmp	.+12     	; 0xc5e <Led_Init+0x52>
 c52:	81 e0       	ldi	r24, 0x01	; 1
 c54:	89 83       	std	Y+1, r24	; 0x01
 c56:	80 e8       	ldi	r24, 0x80	; 128
 c58:	8a 83       	std	Y+2, r24	; 0x02
 c5a:	8f ef       	ldi	r24, 0xFF	; 255
 c5c:	8b 83       	std	Y+3, r24	; 0x03
 c5e:	ce 01       	movw	r24, r28
 c60:	01 96       	adiw	r24, 0x01	; 1
 c62:	49 d0       	rcall	.+146    	; 0xcf6 <DIO_init>
 c64:	0f 90       	pop	r0
 c66:	0f 90       	pop	r0
 c68:	0f 90       	pop	r0
 c6a:	df 91       	pop	r29
 c6c:	cf 91       	pop	r28
 c6e:	08 95       	ret

00000c70 <Led_Toggle>:
	}
}

void Led_Toggle(En_LedNumber_t en_led_id)
{
	switch(en_led_id)
 c70:	81 30       	cpi	r24, 0x01	; 1
 c72:	51 f0       	breq	.+20     	; 0xc88 <Led_Toggle+0x18>
 c74:	28 f0       	brcs	.+10     	; 0xc80 <Led_Toggle+0x10>
 c76:	82 30       	cpi	r24, 0x02	; 2
 c78:	59 f0       	breq	.+22     	; 0xc90 <Led_Toggle+0x20>
 c7a:	83 30       	cpi	r24, 0x03	; 3
 c7c:	69 f0       	breq	.+26     	; 0xc98 <Led_Toggle+0x28>
 c7e:	08 95       	ret
	{
	case LED_0:
		DIO_Toggle(LED_0_GPIO, LED_0_BIT);
 c80:	60 e1       	ldi	r22, 0x10	; 16
 c82:	81 e0       	ldi	r24, 0x01	; 1
 c84:	99 c0       	rjmp	.+306    	; 0xdb8 <DIO_Toggle>
		break;
 c86:	08 95       	ret
	case LED_1:
		DIO_Toggle(LED_1_GPIO, LED_1_BIT);
 c88:	60 e2       	ldi	r22, 0x20	; 32
 c8a:	81 e0       	ldi	r24, 0x01	; 1
 c8c:	95 c0       	rjmp	.+298    	; 0xdb8 <DIO_Toggle>
		break;
 c8e:	08 95       	ret
	case LED_2:
		DIO_Toggle(LED_2_GPIO, LED_2_BIT);
 c90:	60 e4       	ldi	r22, 0x40	; 64
 c92:	81 e0       	ldi	r24, 0x01	; 1
 c94:	91 c0       	rjmp	.+290    	; 0xdb8 <DIO_Toggle>
		break;
	case LED_3:
		DIO_Toggle(LED_3_GPIO, LED_3_BIT);
 c96:	08 95       	ret
 c98:	60 e8       	ldi	r22, 0x80	; 128
 c9a:	81 e0       	ldi	r24, 0x01	; 1
 c9c:	8d c0       	rjmp	.+282    	; 0xdb8 <DIO_Toggle>
 c9e:	08 95       	ret

00000ca0 <vOtherFunction>:



/* Function that creates a task. */
void vOtherFunction( void )
{
 ca0:	ef 92       	push	r14
 ca2:	ff 92       	push	r15
 ca4:	0f 93       	push	r16
 ca6:	cf 93       	push	r28
 ca8:	df 93       	push	r29
 caa:	00 d0       	rcall	.+0      	; 0xcac <vOtherFunction+0xc>
 cac:	cd b7       	in	r28, 0x3d	; 61
 cae:	de b7       	in	r29, 0x3e	; 62

TaskHandle_t xHandle = NULL;
 cb0:	1a 82       	std	Y+2, r1	; 0x02
 cb2:	19 82       	std	Y+1, r1	; 0x01

    /* Create the task, storing the handle. */
    xTaskCreate(
 cb4:	ce 01       	movw	r24, r28
 cb6:	01 96       	adiw	r24, 0x01	; 1
 cb8:	7c 01       	movw	r14, r24
 cba:	00 e0       	ldi	r16, 0x00	; 0
 cbc:	21 e0       	ldi	r18, 0x01	; 1
 cbe:	30 e0       	ldi	r19, 0x00	; 0
 cc0:	44 e6       	ldi	r20, 0x64	; 100
 cc2:	50 e0       	ldi	r21, 0x00	; 0
 cc4:	65 e6       	ldi	r22, 0x65	; 101
 cc6:	70 e0       	ldi	r23, 0x00	; 0
 cc8:	86 e4       	ldi	r24, 0x46	; 70
 cca:	90 e0       	ldi	r25, 0x00	; 0
 ccc:	6c dc       	rcall	.-1832   	; 0x5a6 <xTaskCreate>
                    STACK_SIZE,      /* Stack size in words, not bytes. */
                    ( void * ) 1,    /* Parameter passed into the task. */
                    tskIDLE_PRIORITY,/* Priority at which the task is created. */
                    &xHandle );      /* Used to pass out the created task's handle. */

 xTaskCreate(
 cce:	21 e0       	ldi	r18, 0x01	; 1
 cd0:	30 e0       	ldi	r19, 0x00	; 0
 cd2:	44 e6       	ldi	r20, 0x64	; 100
 cd4:	50 e0       	ldi	r21, 0x00	; 0
 cd6:	6a e6       	ldi	r22, 0x6A	; 106
 cd8:	70 e0       	ldi	r23, 0x00	; 0
 cda:	8b e4       	ldi	r24, 0x4B	; 75
 cdc:	90 e0       	ldi	r25, 0x00	; 0
 cde:	63 dc       	rcall	.-1850   	; 0x5a6 <xTaskCreate>
 STACK_SIZE,      /* Stack size in words, not bytes. */
 ( void * ) 1,    /* Parameter passed into the task. */
 tskIDLE_PRIORITY,/* Priority at which the task is created. */
 &xHandle );      /* Used to pass out the created task's handle. */

}
 ce0:	0f 90       	pop	r0
 ce2:	0f 90       	pop	r0
 ce4:	df 91       	pop	r29
 ce6:	cf 91       	pop	r28
 ce8:	0f 91       	pop	r16
 cea:	ff 90       	pop	r15
 cec:	ef 90       	pop	r14
 cee:	08 95       	ret

00000cf0 <main>:
void vTaskCode( void * pvParameters );

int main(void)
{

	 vOtherFunction();
 cf0:	d7 df       	rcall	.-82     	; 0xca0 <vOtherFunction>
	/*start scheduler*/
	vTaskStartScheduler();
 cf2:	a1 dd       	rcall	.-1214   	; 0x836 <vTaskStartScheduler>
 cf4:	ff cf       	rjmp	.-2      	; 0xcf4 <main+0x4>

00000cf6 <DIO_init>:
 cf6:	fc 01       	movw	r30, r24
            break;
   }

   
   return ERROR;
}
 cf8:	89 2b       	or	r24, r25
 cfa:	09 f4       	brne	.+2      	; 0xcfe <DIO_init+0x8>
 cfc:	51 c0       	rjmp	.+162    	; 0xda0 <DIO_init+0xaa>
 cfe:	80 81       	ld	r24, Z
 d00:	81 30       	cpi	r24, 0x01	; 1
 d02:	c1 f0       	breq	.+48     	; 0xd34 <DIO_init+0x3e>
 d04:	28 f0       	brcs	.+10     	; 0xd10 <DIO_init+0x1a>
 d06:	82 30       	cpi	r24, 0x02	; 2
 d08:	39 f1       	breq	.+78     	; 0xd58 <DIO_init+0x62>
 d0a:	83 30       	cpi	r24, 0x03	; 3
 d0c:	b9 f1       	breq	.+110    	; 0xd7c <DIO_init+0x86>
 d0e:	4a c0       	rjmp	.+148    	; 0xda4 <DIO_init+0xae>
 d10:	82 81       	ldd	r24, Z+2	; 0x02
 d12:	8f 3f       	cpi	r24, 0xFF	; 255
 d14:	31 f4       	brne	.+12     	; 0xd22 <DIO_init+0x2c>
 d16:	9a b3       	in	r25, 0x1a	; 26
 d18:	81 81       	ldd	r24, Z+1	; 0x01
 d1a:	89 2b       	or	r24, r25
 d1c:	8a bb       	out	0x1a, r24	; 26
 d1e:	80 e0       	ldi	r24, 0x00	; 0
 d20:	08 95       	ret
 d22:	81 11       	cpse	r24, r1
 d24:	41 c0       	rjmp	.+130    	; 0xda8 <DIO_init+0xb2>
 d26:	9a b3       	in	r25, 0x1a	; 26
 d28:	81 81       	ldd	r24, Z+1	; 0x01
 d2a:	80 95       	com	r24
 d2c:	89 23       	and	r24, r25
 d2e:	8a bb       	out	0x1a, r24	; 26
 d30:	80 e0       	ldi	r24, 0x00	; 0
 d32:	08 95       	ret
 d34:	82 81       	ldd	r24, Z+2	; 0x02
 d36:	8f 3f       	cpi	r24, 0xFF	; 255
 d38:	31 f4       	brne	.+12     	; 0xd46 <DIO_init+0x50>
 d3a:	97 b3       	in	r25, 0x17	; 23
 d3c:	81 81       	ldd	r24, Z+1	; 0x01
 d3e:	89 2b       	or	r24, r25
 d40:	87 bb       	out	0x17, r24	; 23
 d42:	80 e0       	ldi	r24, 0x00	; 0
 d44:	08 95       	ret
 d46:	81 11       	cpse	r24, r1
 d48:	31 c0       	rjmp	.+98     	; 0xdac <DIO_init+0xb6>
 d4a:	97 b3       	in	r25, 0x17	; 23
 d4c:	81 81       	ldd	r24, Z+1	; 0x01
 d4e:	80 95       	com	r24
 d50:	89 23       	and	r24, r25
 d52:	87 bb       	out	0x17, r24	; 23
 d54:	80 e0       	ldi	r24, 0x00	; 0
 d56:	08 95       	ret
 d58:	82 81       	ldd	r24, Z+2	; 0x02
 d5a:	8f 3f       	cpi	r24, 0xFF	; 255
 d5c:	31 f4       	brne	.+12     	; 0xd6a <DIO_init+0x74>
 d5e:	94 b3       	in	r25, 0x14	; 20
 d60:	81 81       	ldd	r24, Z+1	; 0x01
 d62:	89 2b       	or	r24, r25
 d64:	84 bb       	out	0x14, r24	; 20
 d66:	80 e0       	ldi	r24, 0x00	; 0
 d68:	08 95       	ret
 d6a:	81 11       	cpse	r24, r1
 d6c:	21 c0       	rjmp	.+66     	; 0xdb0 <DIO_init+0xba>
 d6e:	94 b3       	in	r25, 0x14	; 20
 d70:	81 81       	ldd	r24, Z+1	; 0x01
 d72:	80 95       	com	r24
 d74:	89 23       	and	r24, r25
 d76:	84 bb       	out	0x14, r24	; 20
 d78:	80 e0       	ldi	r24, 0x00	; 0
 d7a:	08 95       	ret
 d7c:	82 81       	ldd	r24, Z+2	; 0x02
 d7e:	8f 3f       	cpi	r24, 0xFF	; 255
 d80:	31 f4       	brne	.+12     	; 0xd8e <DIO_init+0x98>
 d82:	91 b3       	in	r25, 0x11	; 17
 d84:	81 81       	ldd	r24, Z+1	; 0x01
 d86:	89 2b       	or	r24, r25
 d88:	81 bb       	out	0x11, r24	; 17
 d8a:	80 e0       	ldi	r24, 0x00	; 0
 d8c:	08 95       	ret
 d8e:	81 11       	cpse	r24, r1
 d90:	11 c0       	rjmp	.+34     	; 0xdb4 <DIO_init+0xbe>
 d92:	91 b3       	in	r25, 0x11	; 17
 d94:	81 81       	ldd	r24, Z+1	; 0x01
 d96:	80 95       	com	r24
 d98:	89 23       	and	r24, r25
 d9a:	81 bb       	out	0x11, r24	; 17
 d9c:	80 e0       	ldi	r24, 0x00	; 0
 d9e:	08 95       	ret
 da0:	81 e0       	ldi	r24, 0x01	; 1
 da2:	08 95       	ret
 da4:	81 e0       	ldi	r24, 0x01	; 1
 da6:	08 95       	ret
 da8:	81 e0       	ldi	r24, 0x01	; 1
 daa:	08 95       	ret
 dac:	81 e0       	ldi	r24, 0x01	; 1
 dae:	08 95       	ret
 db0:	81 e0       	ldi	r24, 0x01	; 1
 db2:	08 95       	ret
 db4:	81 e0       	ldi	r24, 0x01	; 1
 db6:	08 95       	ret

00000db8 <DIO_Toggle>:
*/
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{  /*ERROR RET VARIBALE*/
   ERROR_STATUS EROR=E_OK;
   
   switch (GPIO)
 db8:	81 30       	cpi	r24, 0x01	; 1
 dba:	59 f0       	breq	.+22     	; 0xdd2 <DIO_Toggle+0x1a>
 dbc:	28 f0       	brcs	.+10     	; 0xdc8 <DIO_Toggle+0x10>
 dbe:	82 30       	cpi	r24, 0x02	; 2
 dc0:	69 f0       	breq	.+26     	; 0xddc <DIO_Toggle+0x24>
 dc2:	83 30       	cpi	r24, 0x03	; 3
 dc4:	81 f0       	breq	.+32     	; 0xde6 <DIO_Toggle+0x2e>
 dc6:	14 c0       	rjmp	.+40     	; 0xdf0 <DIO_Toggle+0x38>
   {
      case GPIOA:
            PORTA_DATA^=pins;
 dc8:	8b b3       	in	r24, 0x1b	; 27
 dca:	68 27       	eor	r22, r24
 dcc:	6b bb       	out	0x1b, r22	; 27
*Description: This function toggles the value of a full port, a nibble
* 			  or even one pin.
*/
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{  /*ERROR RET VARIBALE*/
   ERROR_STATUS EROR=E_OK;
 dce:	80 e0       	ldi	r24, 0x00	; 0
   
   switch (GPIO)
   {
      case GPIOA:
            PORTA_DATA^=pins;
            break;
 dd0:	08 95       	ret
      case GPIOB:
            PORTB_DATA^=pins;
 dd2:	88 b3       	in	r24, 0x18	; 24
 dd4:	68 27       	eor	r22, r24
 dd6:	68 bb       	out	0x18, r22	; 24
*Description: This function toggles the value of a full port, a nibble
* 			  or even one pin.
*/
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{  /*ERROR RET VARIBALE*/
   ERROR_STATUS EROR=E_OK;
 dd8:	80 e0       	ldi	r24, 0x00	; 0
      case GPIOA:
            PORTA_DATA^=pins;
            break;
      case GPIOB:
            PORTB_DATA^=pins;
            break;
 dda:	08 95       	ret
      case GPIOC:
           PORTC_DATA^=pins;
 ddc:	85 b3       	in	r24, 0x15	; 21
 dde:	68 27       	eor	r22, r24
 de0:	65 bb       	out	0x15, r22	; 21
*Description: This function toggles the value of a full port, a nibble
* 			  or even one pin.
*/
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{  /*ERROR RET VARIBALE*/
   ERROR_STATUS EROR=E_OK;
 de2:	80 e0       	ldi	r24, 0x00	; 0
      case GPIOB:
            PORTB_DATA^=pins;
            break;
      case GPIOC:
           PORTC_DATA^=pins;
           break;
 de4:	08 95       	ret
      case GPIOD:
          PORTD_DATA^=pins;
 de6:	82 b3       	in	r24, 0x12	; 18
 de8:	68 27       	eor	r22, r24
 dea:	62 bb       	out	0x12, r22	; 18
*Description: This function toggles the value of a full port, a nibble
* 			  or even one pin.
*/
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{  /*ERROR RET VARIBALE*/
   ERROR_STATUS EROR=E_OK;
 dec:	80 e0       	ldi	r24, 0x00	; 0
      case GPIOC:
           PORTC_DATA^=pins;
           break;
      case GPIOD:
          PORTD_DATA^=pins;
          break;
 dee:	08 95       	ret
      default:
          EROR=E_NOK;
 df0:	81 e0       	ldi	r24, 0x01	; 1
   }


   return EROR;
   
 df2:	08 95       	ret

00000df4 <_exit>:
 df4:	f8 94       	cli

00000df6 <__stop_program>:
 df6:	ff cf       	rjmp	.-2      	; 0xdf6 <__stop_program>
